<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>idpmodem.codecs.common_mdf API documentation</title>
<meta name="description" content="Codec functions for IDP Common Message Format supported by Inmarsat MGS â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>idpmodem.codecs.common_mdf</code></h1>
</header>
<section id="section-intro">
<p>Codec functions for IDP Common Message Format supported by Inmarsat MGS.</p>
<p>Also supported on ORBCOMM IGWS.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Codec functions for IDP Common Message Format supported by Inmarsat MGS.

Also supported on ORBCOMM IGWS.

&#34;&#34;&#34;
import logging
import xml.etree.ElementTree as ET
from binascii import b2a_base64
from math import ceil, log2
from struct import pack, unpack
from warnings import warn
from xml.dom.minidom import parseString
from copy import deepcopy

from idpmodem.constants import DataFormat

__version__ = &#39;2.0.0&#39;
_log = logging.getLogger(__name__)


DATA_TYPES = {
    &#39;bool&#39;: &#39;BooleanField&#39;,
    &#39;int_8&#39;: &#39;SignedIntField&#39;,
    &#39;uint_8&#39;: &#39;UnsignedIntField&#39;,
    &#39;int_16&#39;: &#39;SignedIntField&#39;,
    &#39;uint_16&#39;: &#39;UnsignedIntField&#39;,
    &#39;int_32&#39;: &#39;SignedIntField&#39;,
    &#39;uint_32&#39;: &#39;UnsignedIntField&#39;,
    &#39;int_64&#39;: &#39;SignedIntField&#39;,
    &#39;uint_64&#39;: &#39;UnsignedIntField&#39;,
    &#39;float&#39;: &#39;DataField&#39;,
    &#39;double&#39;: &#39;DataField&#39;,
    &#39;string&#39;: &#39;StringField&#39;,
    &#39;data&#39;: &#39;DataField&#39;,
    &#39;enum&#39;: &#39;EnumField&#39;,
    &#39;array&#39;: &#39;ArrayField&#39;,   # TODO: support for array type
}
XML_NAMESPACE = {
    &#39;xsi&#39;: &#39;http://www.w3.org/2001/XMLSchema-instance&#39;,
    &#39;xsd&#39;: &#39;http://www.w3.org/2001/XMLSchema&#39;
}
SIN_RANGE = (16, 255)

for ns in XML_NAMESPACE:
    ET.register_namespace(ns, XML_NAMESPACE[ns])


def optimal_bits(value_range: &#39;tuple[int, int]&#39;) -&gt; int:
    &#34;&#34;&#34;Returns the optimal number of bits for encoding a specified range.
    
    Args:
        value_range: A tuple with the minimum and maximum values.
    
    Returns:
        The number of bits to optimally encode the value.
    
    Raises:
        ValueError if the 

    &#34;&#34;&#34;
    if (not isinstance(value_range, tuple) or
        len(value_range) != 2 or
        not all(isinstance(x, int) for x in value_range) or
        value_range[0] &gt;= value_range[1]):
        #: non-compliant
        raise ValueError(&#39;value_range must be of form (min, max)&#39;)
    total_range = value_range[1] - value_range[0]
    total_range += 1 if value_range[0] == 0 else 0
    return max(1, ceil(log2(value_range[1] - value_range[0])))


def _encode_field_length(length) -&gt; str:
    if length &lt; 128:
        return f&#39;0{length:07b}&#39;
    return f&#39;1{length:015b}&#39;


def _decode_field_length(binstr: str) -&gt; &#39;tuple[int, int]&#39;:
    if binstr[0] == &#39;0&#39;:
        bit_index = 8
    else:
        bit_index = 16
    length = int(binstr[1:bit_index], 2)
    return (length, bit_index)


def _attribute_equivalence(reference: object,
                           other: object,
                           exclude: &#34;list[str]&#34; = None) -&gt; bool:
    for attr, val in reference.__dict__.items():
        if exclude is not None and attr in exclude:
            continue
        if not hasattr(other, attr) or val != other.__dict__[attr]:
            return False
    return True


def _indent_xml(elem: ET.Element, level=0):
    xmlstr = parseString(ET.tostring(elem)).toprettyxml(indent=&#34;  &#34;)
    # i = &#34;\n&#34; + level*&#34;  &#34;
    # j = &#34;\n&#34; + (level-1)*&#34;  &#34;
    # if len(elem):
    #     if not elem.text or not elem.text.strip():
    #         elem.text = i + &#34;  &#34;
    #     if not elem.tail or not elem.tail.strip():
    #         elem.tail = i
    #     for subelem in elem:
    #         _indent_xml(subelem, level+1)
    #     if not elem.tail or not elem.tail.strip():
    #         elem.tail = j
    # else:
    #     if level and (not elem.tail or not elem.tail.strip()):
    #         elem.tail = j
    # return elem
    return xmlstr


class BaseCodec:
    def __init__(self, name: str, description: str = None) -&gt; None:
        if not name or name.strip() == &#39;&#39;:
            raise ValueError(&#39;Invalid name must be non-empty&#39;)
        self._name = name
        self._description = description
    
    @property
    def name(self) -&gt; str:
        return self._name
    
    @property
    def description(self) -&gt; str:
        return self._description
    
    @description.setter
    def description(self, value: str):
        if value is not None and not isinstance(value, str) and not value:
            raise ValueError(&#39;Description must be non-empty string or None&#39;)
        self._description = value


class CodecList(list):
    &#34;&#34;&#34;Base class for a specific object type list.
    
    Used for Fields, Messages, Services.

    Attributes:
        codec_cls: The object type the list is comprised of.

    &#34;&#34;&#34;
    def __init__(self, codec_cls: object):
        super().__init__()
        self.list_type = codec_cls

    def add(self, obj: object) -&gt; bool:
        &#34;&#34;&#34;Add an object to the end of the list.

        Args:
            obj (object): A valid object according to the list_type
        
        Raises:
            ValueError if there is a duplicate or invalid name,
                invalid value_range or unsupported data_type
        &#34;&#34;&#34;
        if not isinstance(obj, self.list_type):
            raise ValueError(f&#39;Invalid {self.list_type} definition&#39;)
        for o in self:
            if o.name == obj.name:
                raise ValueError(f&#39;Duplicate {self.list_type}&#39;
                                 f&#39; name {obj.name} found&#39;)
        self.append(obj)
        return True

    def __getitem__(self, n: &#39;str|int&#39;) -&gt; object:
        &#34;&#34;&#34;Retrieves an object by name or index.
        
        Args:
            n: The object name or list index
        
        Returns:
            object

        &#34;&#34;&#34;
        if isinstance(n, str):
            for o in self:
                if o.name == n:
                    return o
            raise ValueError(f&#39;{self.list_type} name {n} not found&#39;)
        return super().__getitem__(n)

    def __setitem__(self, n: &#39;str|int&#39;, value):
        if isinstance(n, str):
            for o in self:
                if o.name == n:
                    o.value = value
                    break
        else:
            super().__setitem__(n, value)

    def delete(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Delete an object from the list by name.
        
        Args:
            name: The name of the object.

        Returns:
            boolean: success
        &#34;&#34;&#34;
        for o in self:
            if o.name == name:
                self.remove(o)
                return True
        return False


class FieldCodec(BaseCodec):
    &#34;&#34;&#34;The base class for a Field.
    
    Attributes:
        data_type (str): The data type from a supported list.
        name (str): The unique Field name.
        description (str): Optional description.
        optional (bool): Optional indication the field is optional.

    &#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 data_type: str,
                 description: str = None,
                 optional: bool = False) -&gt; None:
        &#34;&#34;&#34;Instantiates the base field.
        
        Args:
            name: The field name must be unique within a Message.
            data_type: The data type represented within the field.
            description: (Optional) Description/purpose of the field.
            optional: (Optional) Indicates if the field is mandatory.
            
        &#34;&#34;&#34;
        super().__init__(name, description)
        if data_type not in DATA_TYPES:
            raise ValueError(f&#39;Invalid data type {data_type}&#39;)
        self._data_type = data_type
        self._optional = optional
    
    @property
    def data_type(self) -&gt; str:
        return self._data_type

    @property
    def optional(self) -&gt; bool:
        return self._optional
    
    @optional.setter
    def optional(self, value: bool):
        if not value or not isinstance(value, bool):
            value = False
        self._optional = value

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define bits&#39;)

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;Must be subclassed.
        
        Args:
            other: The other thing being compared to this.

        &#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define equivalence&#39;)

    def __repr__(self) -&gt; str:
        rep = {}
        for name in dir(self):
            if name.startswith((&#39;__&#39;, &#39;_&#39;)):
                continue
            attr = getattr(self, name)
            if not callable(attr):
                rep[name] = attr
        return repr(rep)
    
    def _base_xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;The default XML template for a Field.&#34;&#34;&#34;
        xsi_type = DATA_TYPES[self.data_type]
        xmlfield = ET.Element(&#39;Field&#39;, attrib={
            &#39;{http://www.w3.org/2001/XMLSchema-instance}type&#39;: xsi_type
        })
        name = ET.SubElement(xmlfield, &#39;Name&#39;)
        name.text = self.name
        if self.description:
            description = ET.SubElement(xmlfield, &#39;Description&#39;)
            description.text = str(self.description)
        if self.optional:
            optional = ET.SubElement(xmlfield, &#39;Optional&#39;)
            optional.text = &#39;true&#39;
        return xmlfield
    
    def decode(self, *args, **kwargs):
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define decode&#39;)
    
    def encode(self, *args, **kwargs):
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define encode&#39;)
    
    def xml(self, *args, **kwargs):
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define xml structure&#39;)
    

class Fields(CodecList):
    &#34;&#34;&#34;The list of Fields defining a Message or ArrayElement.&#34;&#34;&#34;
    def __init__(self, fields: &#39;list[FieldCodec]&#39; = None):
        super().__init__(codec_cls=FieldCodec)
        if fields is not None:
            for field in fields:
                self.add(field)
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, Fields):
            return NotImplemented
        if len(self) != len(other):
            return False
        for i, field in enumerate(self):
            if field != other[i]:
                return False
        return True


class MessageCodec(BaseCodec):
    &#34;&#34;&#34;The Payload structure for Message Definition Files uploaded to a Mailbox.
    
    Attributes:
        name (str): The message name
        sin (int): The Service Identification Number
        min (int): The Message Identification Number
        fields (list): A list of Fields
        description (str): Optional description
        is_forward (bool): Indicates if the message is mobile-terminated

    &#34;&#34;&#34;

    def __init__(self,
                 name: str,
                 sin: int,
                 min: int,
                 description: str = None,
                 is_forward: bool = False,
                 fields: Fields = None):
        &#34;&#34;&#34;Instantiates a Message.
        
        Args:
            name: The message name should be unique within the xMessages list.
            sin: The Service Identification Number (16..255)
            min: The Message Identification Number (0..255)
            description: (Optional) Description/purpose of the Message.
            is_forward: Indicates if the message is intended to be
                Mobile-Terminated.
            fields: Optional definition of fields during instantiation.

        &#34;&#34;&#34;
        if not isinstance(sin, int) or sin not in range(16, 256):
            raise ValueError(f&#39;Invalid SIN {sin} must be in range 16..255&#39;)
        if not isinstance(min, int) or min not in range (0, 256):
            raise ValueError(f&#39;Invalid MIN {min} must be in range 0..255&#39;)
        super().__init__(name, description)
        self._is_forward = is_forward
        self._sin = sin
        self._min = min
        self._fields: Fields = fields or Fields()

    @property
    def is_forward(self) -&gt; bool:
        return self._is_forward
    
    @property
    def sin(self) -&gt; int:
        return self._sin

    @property
    def min(self) -&gt; int:
        return self._min

    @property
    def fields(self) -&gt; Fields:
        return self._fields
    
    @fields.setter
    def fields(self, fields: Fields):
        if not all(isinstance(field, FieldCodec) for field in fields):
            raise ValueError(&#39;Invalid field found in list&#39;)
        self._fields = fields

    @property
    def ota_size(self) -&gt; int:
        ota_bits = 2 * 8
        for field in self.fields:
            assert isinstance(field, FieldCodec)
            ota_bits += field.bits + (1 if field.optional else 0)
        return ceil(ota_bits / 8)

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, MessageCodec):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def decode(self, databytes: bytes) -&gt; None:
        &#34;&#34;&#34;Parses and stores field values from raw data (received over-the-air).
        
        Args:
            databytes: A bytes array (typically from the forward message)
        &#34;&#34;&#34;
        binary_str = &#39;&#39;.join(format(int(b), &#39;08b&#39;) for b in databytes)
        bit_offset = 16   #: Begin after SIN/MIN bytes
        for field in self.fields:
            assert isinstance(field, FieldCodec)
            if field.optional:
                present = binary_str[bit_offset] == &#39;1&#39;
                bit_offset += 1
                if not present:
                    continue
            bit_offset += field.decode(binary_str[bit_offset:])

    def encode(self,
               data_format: int = DataFormat.BASE64,
               exclude: list = None) -&gt; dict:
        &#34;&#34;&#34;Encodes using the specified data format (base64 or hex).

        Args:
            data_format (int): 2=ASCII-Hex, 3=base64
            exclude (list[str]): A list of optional field names to exclude
        
        Returns:
            Dictionary with sin, min, data_format and data to pass into AT%MGRT
                or atcommand function `message_mo_send`
        &#34;&#34;&#34;
        if data_format not in [DataFormat.BASE64, DataFormat.HEX]:
            raise ValueError(f&#39;data_format {data_format} unsupported&#39;)
        bin_str = &#39;&#39;
        for field in self.fields:
            assert isinstance(field, FieldCodec)
            if field.optional:
                if exclude is not None and field.name in exclude:
                    present = False
                elif hasattr(field, &#39;value&#39;):
                    present = field.value is not None
                elif hasattr(field, &#39;elements&#39;):
                    present = field.elements is not None
                else:
                    raise ValueError(&#39;Unknown value of optional&#39;)
                bin_str += &#39;1&#39; if present else &#39;0&#39;
                if not present:
                    continue
            bin_str += field.encode()
        for _ in range(0, 8 - len(bin_str) % 8):   #:pad to next byte
            bin_str += &#39;0&#39;
        _format = f&#39;0{int(len(bin_str) / 8 * 2)}X&#39;   #:hex bytes 2 chars
        hex_str = format(int(bin_str, 2), _format)
        if (self.is_forward and len(hex_str) / 2 &gt; 9998 or
            not self.is_forward and len(hex_str) / 2 &gt; 6398):
            raise ValueError(f&#39;{len(hex_str) / 2} bytes exceeds maximum size&#39;
                             &#39; for Payload&#39;)
        if data_format == DataFormat.HEX:
            data = hex_str
        else:
            data = b2a_base64(bytearray.fromhex(hex_str)).strip().decode()
        return {
            &#39;sin&#39;: self.sin,
            &#39;min&#39;: self.min,
            &#39;data_format&#39;: data_format,
            &#39;data&#39;: data
        }

    def xml(self, indent: bool = False) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the XML definition for a Message Definition File.&#34;&#34;&#34;
        xmessage = ET.Element(&#39;Message&#39;)
        name = ET.SubElement(xmessage, &#39;Name&#39;)
        name.text = self.name
        min = ET.SubElement(xmessage, &#39;MIN&#39;)
        min.text = str(self.min)
        fields = ET.SubElement(xmessage, &#39;Fields&#39;)
        for field in self.fields:
            fields.append(field.xml())
        return xmessage if not indent else _indent_xml(xmessage)


class Messages(CodecList):
    &#34;&#34;&#34;The list of Messages (Forward or Return) within a Service.&#34;&#34;&#34;
    def __init__(self, sin: int, is_forward: bool):
        super().__init__(codec_cls=MessageCodec)
        self.sin = sin
        self.is_forward = is_forward
    
    def add(self, message: MessageCodec) -&gt; None:
        &#34;&#34;&#34;Add a message to the list if it matches the parent SIN.

        Overrides the base class add method.

        Args:
            message (object): A valid Message
        
        Raises:
            ValueError if there is a duplicate or invalid name,
                invalid value_range or unsupported data_type

        &#34;&#34;&#34;
        if not isinstance(message, MessageCodec):
            raise ValueError(&#39;Invalid message definition&#39;)
        if message.sin != self.sin:
            raise ValueError(f&#39;Message SIN {message.sin} does not match&#39;
                             f&#39; service {self.sin}&#39;)
        for m in self:
            assert isinstance(m, MessageCodec)
            if m.name == message.name:
                raise ValueError(f&#39;Duplicate message name {message.name} found&#39;)
            if m.min == message.min:
                raise ValueError(f&#39;Duplicate message MIN {message.min} found&#39;)
        self.append(message)


class ServiceCodec(BaseCodec):
    &#34;&#34;&#34;A data structure holding a set of related Forward and Return Messages.
    
    Attributes:
        name (str): The service name
        sin (int): Service Identification Number or codec service id (16..255)
        description (str): A description of the service (unsupported)
        messages_forward (list): A list of mobile-terminated Message definitions
        messages_return (list): A list of mobile-originated Message definitions

    &#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 sin: int,
                 description: str = None,
                 messages_forward: Messages = None,
                 messages_return: Messages = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a Service made up of Messages.
        
        Args:
            name: The service name should be unique within a MessageDefinitions
            sin: The Service Identification Number (16..255)
            description: (Optional)
        &#34;&#34;&#34;
        if not isinstance(name, str) or name == &#39;&#39;:
            raise ValueError(f&#39;Invalid service name {name}&#39;)
        if sin not in range(16, 256):
            raise ValueError(&#39;Invalid SIN must be 16..255&#39;)
        if description is not None:
            warn(&#39;Service Description not currently supported&#39;)
        super().__init__(name, description)
        self._sin = sin
        self._messages_forward = (messages_forward or
                                  Messages(self.sin, is_forward=True))
        self._messages_return = (messages_return or
                                 Messages(self.sin, is_forward=False))
    
    @property
    def sin(self) -&gt; int:
        return self._sin
    
    @property
    def messages_forward(self) -&gt; Messages:
        return self._messages_forward
    
    @messages_forward.setter
    def messages_forward(self, messages: Messages):
        if not isinstance(messages, Messages):
            raise ValueError(&#39;Invalid messages list&#39;)
        for message in messages:
            assert isinstance(message, MessageCodec)
            if not message.is_forward:
                raise ValueError(f&#39;Message {message.name} is_forward is False&#39;)
        self._messages_forward = messages

    @property
    def messages_return(self) -&gt; Messages:
        return self._messages_return
    
    @messages_return.setter
    def messages_return(self, messages: Messages):
        if not isinstance(messages, Messages):
            raise ValueError(&#39;Invalid messages list&#39;)
        for message in messages:
            assert isinstance(message, MessageCodec)
            if message.is_forward:
                raise ValueError(f&#39;Message {message.name} is_forward is True&#39;)
        self._messages_return = messages
        
    def xml(self, indent: bool = False) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the Service.&#34;&#34;&#34;
        if len(self.messages_forward) == 0 and len(self.messages_return) == 0:
            raise ValueError(f&#39;No messages defined for service {self.sin}&#39;)
        xservice = ET.Element(&#39;Service&#39;)
        name = ET.SubElement(xservice, &#39;Name&#39;)
        name.text = str(self.name)
        sin = ET.SubElement(xservice, &#39;SIN&#39;)
        sin.text = str(self.sin)
        if self.description:
            desc = ET.SubElement(xservice, &#39;Description&#39;)
            desc.text = str(self.description)
        if len(self.messages_forward) &gt; 0:
            forward_messages = ET.SubElement(xservice, &#39;ForwardMessages&#39;)
            for m in self.messages_forward:
                forward_messages.append(m.xml())
        if len(self.messages_return) &gt; 0:
            return_messages = ET.SubElement(xservice, &#39;ReturnMessages&#39;)
            for m in self.messages_return:
                return_messages.append(m.xml())
        return xservice if not indent else _indent_xml(xservice)


class Services(CodecList):
    &#34;&#34;&#34;The list of Service(s) within a MessageDefinitions.&#34;&#34;&#34;
    def __init__(self, services: &#39;list[ServiceCodec]&#39; = None):
        super().__init__(codec_cls=ServiceCodec)
        if services is not None:
            for service in services:
                if not isinstance(service, ServiceCodec):
                    raise ValueError(f&#39;Invalid Service {service}&#39;)
                self.add(service)
    
    def add(self, service: ServiceCodec) -&gt; None:
        &#34;&#34;&#34;Adds a Service to the list of Services.&#34;&#34;&#34;
        if not isinstance(service, ServiceCodec):
            raise ValueError(f&#39;{service} is not a valid Service&#39;)
        if service.name in self:
            raise ValueError(f&#39;Duplicate Service {service.name}&#39;)
        for existing_service in self:
            if existing_service.sin == service.sin:
                raise ValueError(f&#39;Duplicate SIN {service.sin}&#39;)
        self.append(service)


class BooleanField(FieldCodec):
    &#34;&#34;&#34;A Boolean field.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 description: str = None,
                 optional: bool = False,
                 default: bool = False,
                 value: bool = None) -&gt; None:
        super().__init__(name=name,
                         data_type=&#39;bool&#39;,
                         description=description,
                         optional=optional)
        &#34;&#34;&#34;Instantiates a BooleanField.
        
        Args:
            name: The field name must be unique within a Message.
            description: An optional description/purpose for the field.
            optional: Indicates if the field is optional in the Message.
            default: A default value for the boolean.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        self._default = default if isinstance(default, bool) else False
        self._value = value if value is not None else self._default
    
    @property
    def default(self):
        return self._default

    @default.setter
    def default(self, v: bool):
        if v is not None and not isinstance(v, bool):
            raise ValueError(f&#39;Invalid boolean value {v}&#39;)
        self._default = v

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, v: bool):
        if v is not None and not isinstance(v, bool):
            raise ValueError(f&#39;Invalid boolean value {v}&#39;)
        self._value = v

    @property
    def bits(self):
        return 1
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, BooleanField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None and not self.optional:
            raise ValueError(&#39;No value assigned to field&#39;)
        return &#39;1&#39; if self.value else &#39;0&#39;

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        self.value = True if binary_str[0] == &#39;1&#39; else False
        return 1

    def xml(self) -&gt; ET.Element:
        xmlfield = self._base_xml()
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = &#39;true&#39;
        return xmlfield


class EnumField(FieldCodec):
    &#34;&#34;&#34;An enumerated field sends an index over-the-air representing a string.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 items: &#39;list[str]&#39;,
                 size: int,
                 description: str = None,
                 optional: bool = False,
                 default: int = None,
                 value: int = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a EnumField.
        
        Args:
            name: The field name must be unique within a Message.
            items: A list of strings (indexed from 0).
            size: The number of *bits* used to encode the index over-the-air.
            description: An optional description/purpose for the field.
            optional: Indicates if the field is optional in the Message.
            default: A default value for the enum.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        super().__init__(name=name,
                         data_type=&#39;enum&#39;,
                         description=description,
                         optional=optional)
        if (not isinstance(items, list) or
            not all(isinstance(item, str) for item in items)):
            raise ValueError(&#39;Items must a list of strings&#39;)
        if not isinstance(size, int) or size &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bits&#39;)
        self._items = items
        self._size = size
        self._default = (default if default in range(0, len(self._items))
                         else None)
        self._value = value if value is not None else self._default
    
    def _validate_enum(self, v: &#39;int|str&#39;) -&gt; &#39;int|None&#39;:
        if v is not None:
            if isinstance(v, str):
                if v not in self.items:
                    raise ValueError(f&#39;Invalid value {v}&#39;)
                for index, item in enumerate(self.items):
                    if item == v:
                        return index
            elif isinstance(v, int):
                if v &lt; 0 or v &gt;= len(self.items):
                    raise ValueError(f&#39;Invalid enum index {v}&#39;)
            else:
                raise ValueError(f&#39;Invalid value {v}&#39;)
        return v

    @property
    def items(self):
        return self._items
    
    @items.setter
    def items(self, l: list):
        if not isinstance(l, list) or not all(isinstance(x, str) for x in l):
            raise ValueError(&#39;Items must be a list of strings&#39;)
        self._items = l

    @property
    def default(self) -&gt; str:
        if self._default is None:
            return None
        return self.items[self._default]
    
    @default.setter
    def default(self, v: &#39;int|str&#39;):
        self._default = self._validate_enum(v)

    @property
    def value(self) -&gt; str:
        if self._value is None:
            return None
        return self.items[self._value]
    
    @value.setter
    def value(self, v: &#39;int|str&#39;):
        self._value = self._validate_enum(v)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, v: int):
        if not isinstance(v, int) or v &lt; 1:
            raise ValueError(&#39;Size must be integer greater than zero&#39;)
        minimum_bits = optimal_bits((0, len(self.items)))
        if v &lt; minimum_bits:
            raise ValueError(f&#39;Size must be at least {minimum_bits}&#39;
                             &#39; to support item count&#39;)
        self._size = v

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self.size
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, EnumField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None:
            raise ValueError(f&#39;No value configured in EnumField {self.name}&#39;)
        _format = f&#39;0{self.bits}b&#39;
        binstr = format(self.items.index(self.value), _format)
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        self.value = binary_str[:self.bits]
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the EnumField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        items = ET.SubElement(xmlfield, &#39;Items&#39;)
        for string in self.items:
            item = ET.SubElement(items, &#39;string&#39;)
            item.text = str(string)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield


class UnsignedIntField(FieldCodec):
    &#34;&#34;&#34;An unsigned integer value using a defined number of bits over-the-air.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 data_type: str = &#39;uint_16&#39;,
                 description: str = None,
                 optional: bool = False,
                 default: int = None,
                 value: int = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a UnsignedIntField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The number of *bits* used to encode the integer over-the-air
                (maximum 32).
            data_type: The integer type represented (for decoding).
            description: An optional description/purpose for the string.
            optional: Indicates if the string is optional in the Message.
            default: A default value for the string.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        if data_type not in [&#39;uint_8&#39;, &#39;uint_16&#39;, &#39;uint_32&#39;]:
            raise ValueError(f&#39;Invalid unsignedint type {data_type}&#39;)
        super().__init__(name=name,
                         data_type=data_type,
                         description=description,
                         optional=optional)
        self._size = size
        self._default = default
        self._value = value if value is not None else self._default
    
    @property
    def size(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self._size

    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bits&#39;)
        data_type_size = int(self.data_type.split(&#39;_&#39;)[1])
        if value &gt; data_type_size:
            warn(f&#39;Size {value} larger than required by {self.data_type}&#39;)
        self._size = value

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, v: int):
        clip = False
        if v is not None:
            if not isinstance(v, int) or v &lt; 0:
                raise ValueError(&#39;Unsignedint must be non-negative integer&#39;)
            if v &gt; 2**self.size - 1:
                self._value = 2**self.size - 1
                warn(f&#39;Clipping unsignedint at max value {self._value}&#39;)
                clip = True
        if not clip:
            self._value = v
    
    @property
    def default(self):
        &#34;&#34;&#34;The default value.&#34;&#34;&#34;
        return self._default
    
    @default.setter
    def default(self, v: int):
        if v is not None:
            if v &gt; 2**self.size - 1 or v &lt; 0:
                raise ValueError(F&#39;Invalid unsignedint default {v}&#39;)
        self._default = v
    
    @property
    def bits(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self.size
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, UnsignedIntField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None:
            raise ValueError(f&#39;No value defined in UnsignedIntField {self.name}&#39;)
        _format = f&#39;0{self.bits}b&#39;
        return format(self.value, _format)

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        self.value = int(binary_str[:self.bits], 2)
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the UnsignedIntField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield


class SignedIntField(FieldCodec):
    &#34;&#34;&#34;A signed integer value using a defined number of bits over-the-air.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 data_type: str = &#39;int_16&#39;,
                 description: str = None,
                 optional: bool = False,
                 default: int = None,
                 value: int = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a SignedIntField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The number of *bits* used to encode the integer over-the-air
                (maximum 32).
            data_type: The integer type represented (for decoding).
            description: An optional description/purpose for the string.
            optional: Indicates if the string is optional in the Message.
            default: A default value for the string.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        if data_type not in [&#39;int_8&#39;, &#39;int_16&#39;, &#39;int_32&#39;]:
            raise ValueError(f&#39;Invalid unsignedint type {data_type}&#39;)
        super().__init__(name=name,
                         data_type=data_type,
                         description=description,
                         optional=optional)
        self._size = size
        self._default = default
        self._value = value if value is not None else self._default
    
    @property
    def size(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self._size

    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bits&#39;)
        self._size = value

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, v: int):
        clip = False
        if v is not None:
            if not isinstance(v, int):
                raise ValueError(&#39;Unsignedint must be non-negative integer&#39;)
            if v &gt; (2**self.size / 2) - 1:
                self._value = int(2**self.size / 2) - 1
                warn(f&#39;Clipping signedint at max value {self._value}&#39;)
                clip = True
            if v &lt; -(2**self.size / 2):
                self._value = -1 * int(2**self.size / 2)
                warn(f&#39;Clipping signedint at min value {self._value}&#39;)
                clip = True
        if not clip:
            self._value = v
    
    @property
    def default(self):
        &#34;&#34;&#34;The default value.&#34;&#34;&#34;
        return self._default
    
    @default.setter
    def default(self, v: int):
        if v is not None:
            if not isinstance(v, int):
                raise ValueError(f&#39;Invalid signed integer {v}&#39;)
            if v &gt; (2**self.size / 2) - 1 or v &lt; -(2**self.size / 2):
                raise ValueError(f&#39;Invalid default {v}&#39;)
        self._default = v
    
    @property
    def bits(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self.size
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, SignedIntField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None:
            raise ValueError(f&#39;No value defined in UnsignedIntField {self.name}&#39;)
        _format = f&#39;0{self.bits}b&#39;
        if self.value &lt; 0:
            invertedbin = format(self.value * -1, _format)
            twocomplementbin = &#39;&#39;
            i = 0
            while len(twocomplementbin) &lt; len(invertedbin):
                twocomplementbin += &#39;1&#39; if invertedbin[i] == &#39;0&#39; else &#39;0&#39;
                i += 1
            binstr = format(int(twocomplementbin, 2) + 1, _format)
        else:
            binstr = format(self.value, _format)
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        value = int(binary_str[:self.bits], 2)
        if (value &amp; (1 &lt;&lt; (self.bits - 1))) != 0:   #:sign bit set e.g. 8bit: 128-255
            value = value - (1 &lt;&lt; self.bits)        #:compute negative value
        self.value = value
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the SignedIntField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield


class StringField(FieldCodec):
    &#34;&#34;&#34;A character string sent over-the-air.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 description: str = None,
                 optional: bool = False,
                 fixed: bool = False,
                 default: str = None,
                 value: str = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a StringField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The maximum number of characters in the string.
            description: An optional description/purpose for the string.
            optional: Indicates if the string is optional in the Message.
            fixed: Indicates if the string is always fixed length `size`.
            default: A default value for the string.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        super().__init__(name=name,
                         data_type=&#39;string&#39;,
                         description=description,
                         optional=optional)
        self._size = size
        self._fixed = fixed
        self._default = default
        self._value = value if value is not None else self._default
    
    def _validate_string(self, s: str) -&gt; str:
        if s is not None:
            if not isinstance(s, str):
                raise ValueError(f&#39;Invalid string {s}&#39;)
            if len(s) &gt; self.size:
                warn(f&#39;Clipping string at max {self.size} characters&#39;)
                return s[:self.size]
        return s
                
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The maximum size of the string in characters.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 characters&#39;)
        self._size = value
    
    @property
    def default(self) -&gt; str:
        &#34;&#34;&#34;The default value.&#34;&#34;&#34;
        return self._default
    
    @default.setter
    def default(self, v: str):
        self._default = self._validate_string(v)

    @property
    def value(self) -&gt; str:
        return self._value
    
    @value.setter
    def value(self, v: str):
        self._value = self._validate_string(v)

    @property
    def fixed(self) -&gt; bool:
        &#34;&#34;&#34;Indicates whether the string length is fixed (padded/truncated).&#34;&#34;&#34;
        return self._fixed

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        if self.fixed or self.value is None:
            return self.size * 8
        return len(self.value) * 8
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, StringField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None and not self.optional:
            raise ValueError(f&#39;No value defined for StringField {self.name}&#39;)
        binstr = &#39;&#39;.join(format(ord(c), &#39;08b&#39;) for c in self.value)
        if self.fixed:
            binstr += &#39;&#39;.join(&#39;0&#39; for bit in range(len(binstr), self.bits))
        else:
            binstr = _encode_field_length(len(self.value)) + binstr
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        if self.fixed:
            length = self.size
            bit_index = 0
        else:
            (length, bit_index) = _decode_field_length(binary_str)
        n = int(binary_str[bit_index:bit_index + length * 8], 2)
        char_bytes = n.to_bytes((n.bit_length() + 7) // 8, &#39;big&#39;)
        for i, byte in enumerate(char_bytes):
            if byte == 0:
                warn(&#39;Truncating after 0 byte in string&#39;)
                char_bytes = char_bytes[:i]
                break
        self.value = char_bytes.decode(&#39;utf-8&#39;, &#39;surrogatepass&#39;) or &#39;\0&#39;
        return bit_index + length * 8

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the StringField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.fixed:
            fixed = ET.SubElement(xmlfield, &#39;Fixed&#39;)
            fixed.text = &#39;true&#39;
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield


class DataField(FieldCodec):
    &#34;&#34;&#34;A data field of raw bytes sent over-the-air.
    
    Can also be used to hold floating point, double-precision or large integers.

    &#34;&#34;&#34;
    SUPPORTED_DATA_TYPES = [&#39;data&#39;, &#39;float&#39;, &#39;double&#39;]
    def __init__(self,
                 name: str,
                 size: int,
                 data_type: str = &#39;data&#39;,
                 precision: int = None,
                 description: str = None,
                 optional: bool = False,
                 fixed: bool = False,
                 default: bytes = None,
                 value: bytes = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a EnumField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The maximum number of bytes to send over-the-air.
            data_type: The data type represented within the bytes.
            description: An optional description/purpose for the field.
            optional: Indicates if the field is optional in the Message.
            fixed: Indicates if the data bytes are a fixed `size`.
            default: A default value for the enum.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        if data_type is None or data_type not in self.SUPPORTED_DATA_TYPES:
            raise ValueError(f&#39;Invalid data type {data_type}&#39;)
        super().__init__(name=name,
                         data_type=data_type,
                         description=description,
                         optional=optional)
        self._fixed = fixed
        self._size = size
        self._default = default
        self._precision = precision
        self._value = self._default
        if value:
            self.value = value
    
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The maximum size of the field in bytes.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bytes&#39;)
        if self.data_type == &#39;float&#39;:
            if value != 4:
                warn(&#39;Adjusting float size to 4 bytes fixed&#39;)
            self._size = 4
            self.fixed = True
        elif self.data_type == &#39;double&#39;:
            if value != 8:
                warn(&#39;Adjusting double size to 8 bytes fixed&#39;)
            self._size = 8
            self.fixed = True
        else:
            self._size = value
    
    def _validate_data(self, v: &#39;bytes|float&#39;) -&gt; bytes:
        &#34;&#34;&#34;Ensures the data is of the target field size and encoding.&#34;&#34;&#34;
        data_type = self.data_type
        if not ((isinstance(v, bytes) and data_type == &#39;data&#39;) or
                (isinstance(v, float) and data_type in [&#39;float&#39;, &#39;double&#39;])):
            raise ValueError(f&#39;Data {type(v)} does not match {data_type}&#39;)
        if data_type in [&#39;float&#39;, &#39;double&#39;]:
            _format = &#39;!f&#39; if data_type == &#39;float&#39; else &#39;!d&#39;
            v = pack(_format, v)
        assert isinstance(v, bytes)
        if self.fixed:
            if len(v) &gt; self.size:
                warn(f&#39;Truncating data to {self.size} bytes&#39;)
                return v[0:self.size]
            elif len(v) &lt; self.size:
                warn(f&#39;Padding data to {self.size} bytes&#39;)
                return v.ljust(self.size, b&#39;\0&#39;)
        return v

    def _convert_to_float(self, v: bytes) -&gt; &#39;float|None&#39;:
        if not self.data_type in (&#39;float&#39;, &#39;double&#39;):
            return None
        convertor = &#39;!f&#39; if self.data_type == &#39;float&#39; else &#39;!d&#39;
        converted = unpack(convertor, v)[0]
        if self.precision:
            converted = round(converted, self.precision)
        return converted

    @property
    def default(self) -&gt; &#39;bytes|float&#39;:
        &#34;&#34;&#34;The default value, converted for float or double data types.&#34;&#34;&#34;
        if self.data_type in [&#39;float&#39;, &#39;double&#39;]:
            return self._convert_to_float(self._default)
        return self._default
    
    @default.setter
    def default(self, v: &#39;bytes|float&#39;):
        self._default = self._validate_data(v)

    @property
    def precision(self) -&gt; &#39;int|None&#39;:
        &#34;&#34;&#34;The number of decimal places for `float` or `double` data types.&#34;&#34;&#34;
        return self._precision

    @property
    def converted_value(self) -&gt; &#39;float|None&#39;:
        &#34;&#34;&#34;The converted value for `float` and `double` data types.&#34;&#34;&#34;
        return self._convert_to_float(self._value)
    
    @property
    def value(self):
        &#34;&#34;&#34;The raw binary value.&#34;&#34;&#34;
        return self._value

    @value.setter
    def value(self, v: &#39;bytes|float&#39;):
        self._value = self._validate_data(v)

    @property
    def fixed(self) -&gt; bool:
        &#34;&#34;&#34;Indicates if the field is fixed size (padded/truncated).&#34;&#34;&#34;
        return self._fixed

    @property
    def bits(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        if self.fixed:
            return self.size * 8
        elif self._value is None:
            return 0
        return len(self._value) * 8
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, DataField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None and not self.optional:
            raise ValueError(f&#39;No value defined for DataField {self.name}&#39;)
        binstr = &#39;&#39;
        binstr = &#39;&#39;.join(format(b, &#39;08b&#39;) for b in self._value)
        if self.fixed:   #:pad to fixed length
            binstr += &#39;&#39;.join(&#39;0&#39; for bit in range(len(binstr), self.bits))
        else:
            binstr = _encode_field_length(len(self._value)) + binstr
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        if self.fixed:
            binary = binary_str[:self.bits]
            bits = self.bits
        else:
            (length, bit_index) = _decode_field_length(binary_str)
            binary = binary_str[bit_index:length * 8 + bit_index]
            bits = len(binary)
        self._value = int(binary, 2).to_bytes(int(bits / 8), &#39;big&#39;)
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;The XML structure of the DataField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield


class ArrayField(FieldCodec):
    &#34;&#34;&#34;An Array Field provides a list where each element is a set of Fields.
    
    Attributes:
        name (str): The name of the field instance.
        size (int): The maximum number of elements allowed.
        fields (Fields): A list of Field types comprising each ArrayElement
        description (str): An optional description of the array/use.
        optional (bool): Indicates if the array is optional in the Message
        fixed (bool): Indicates if the array is always the fixed `size`
        elements (list): The enumerated list of ArrayElements

    &#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 fields: Fields,
                 description: str = None,
                 optional: bool = False,
                 fixed: bool = False,
                 elements: &#39;list[Fields]&#39; = []) -&gt; None:
        &#34;&#34;&#34;Initializes an ArrayField instance.
        
        Args:
            name: The unique field name within the Message.
            size: The maximum number of elements allowed.
            fields: The list of Field types comprising each element.
            description: An optional description/purpose of the array.
            optional: Indicates if the array is optional in the Message.
            fixed: Indicates if the array is always the fixed `size`.
            elements: Option to populate elements of Fields during instantiation.

        &#34;&#34;&#34;
        super().__init__(name=name,
                         data_type=&#39;array&#39;,
                         description=description,
                         optional=optional)
        self._size = size
        self._fixed = fixed
        self._fields = fields
        self._elements = elements or []
    
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The maximum number of array elements.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0&#39;)
        self._size = value
    
    @property
    def fixed(self) -&gt; bool:
        &#34;&#34;&#34;Indicates if the array is a fixed size (padded with defaults).&#34;&#34;&#34;
        return self._fixed

    @property
    def fields(self) -&gt; Fields:
        &#34;&#34;&#34;The set of `FieldCodec`s that make up each array element.&#34;&#34;&#34;
        return self._fields

    @fields.setter
    def fields(self, fields: Fields):
        if not isinstance(fields, Fields):
            raise ValueError(&#39;Invalid Fields definition for ArrayField&#39;)
        self._fields = fields

    @property
    def elements(self) -&gt; &#39;list[Fields]&#39;:
        &#34;&#34;&#34;The list of elements (field sets) in the array.&#34;&#34;&#34;
        return self._elements
    
    @elements.setter
    def elements(self, elements: &#39;list[Fields]&#39;):
        if (not isinstance(elements, list) or 
            not all(isinstance(item, Fields) for item in elements)):
            raise ValueError(&#39;Elements must be a list of grouped Fields&#39;)
        for fields in elements:
            # assert isinstance(fields, Fields)
            for index, field in enumerate(fields):
                assert isinstance(field, FieldCodec)
                if (field.name != self.fields[index].name):
                    raise ValueError(f&#39;fields[{index}].name&#39;
                                     f&#39; expected {self.fields[index].name}&#39;
                                     f&#39; got {field.name}&#39;)
                if (field.data_type != self.fields[index].data_type):
                    raise ValueError(f&#39;fields[{index}].data_type&#39;
                                     f&#39; expected {self.fields[index].data_type}&#39;
                                     f&#39; got {field.data_type}&#39;)
                #TODO: validate non-optional fields have value/elements
                if (not field.optional and
                    not isinstance(field, ArrayField) and
                    field.value is None):
                    raise ValueError(f&#39;fields[{index}].value missing&#39;)
                try:
                    self._elements[index] = fields
                except IndexError:
                    self._elements.append(fields)

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;The size of the array in bits.&#34;&#34;&#34;
        bits = 0
        for field in self.fields:
            # assert isinstance(field, FieldCodec)
            bits += field.bits
        return bits
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, ArrayField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def _valid_element(self, element: Fields) -&gt; bool:
        for i, field in enumerate(self.fields):
            # assert isinstance(field, FieldCodec)
            e_field = element[i]
            # assert isinstance(e_field, FieldCodec)
            if e_field.name != field.name:
                raise ValueError(f&#39;element field name {e_field.name}&#39;
                                 f&#39; does not match {field.name}&#39;)
            if e_field.data_type != field.data_type:
                raise ValueError(f&#39;element field data_type {e_field.data_type}&#39;
                                 f&#39; does not match {field.data_type}&#39;)
            if e_field.optional != field.optional:
                raise ValueError(f&#39;element optional {e_field.optional}&#39;
                                 f&#39; does not match {field.optional}&#39;)
            if (hasattr(field, &#39;fixed&#39;) and
                hasattr(e_field, &#39;fixed&#39;) and
                e_field.fixed != field.fixed):
                raise ValueError(f&#39;element fixed {e_field.fixed}&#39;
                                 f&#39; does not match {field.fixed}&#39;)
            if (hasattr(field, &#39;size&#39;) and
                hasattr(e_field, &#39;size&#39;) and
                e_field.size != field.size):
                raise ValueError(f&#39;element size {e_field.size}&#39;
                                 f&#39; does not match {field.size}&#39;)
        return True

    def _append(self, element: Fields):
        &#34;&#34;&#34;Adds the array element to the list of elements.&#34;&#34;&#34;
        if not isinstance(element, Fields):
            raise ValueError(&#39;Invalid element definition must be Fields&#39;)
        if self._valid_element(element):
            for i, field in enumerate(element):
                assert isinstance(field, FieldCodec)
                if (hasattr(field, &#39;description&#39;) and
                    field.description != self.fields[i].description):
                    element[i].description = self.fields[i].description
                if hasattr(field, &#39;value&#39;) and field.value is None:
                    element[i].value = self.fields[i].default
            self._elements.append(element)

    def new_element(self) -&gt; Fields:
        &#34;&#34;&#34;Returns an empty element at the end of the elements list.&#34;&#34;&#34;
        new_index = len(self._elements)
        new_fields = deepcopy(self.fields)
        self._append(Fields(new_fields))
        return self.elements[new_index]

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if len(self.elements) == 0:
            raise ValueError(&#39;No elements to encode&#39;)
        binstr = &#39;&#39;
        for element in self.elements:
            for field in element:
                binstr += field.encode()
        if not self.fixed:
            binstr = _encode_field_length(len(self.elements)) + binstr
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        if self.fixed:
            length = self.size
            bit_index = 0
        else:
            (length, bit_index) = _decode_field_length(binary_str)
        for index in range(0, length):
            fields = Fields(self.fields)
            for field in fields:
                if field.optional:
                    if binary_str[bit_index] == &#39;0&#39;:
                        bit_index += 1
                        continue
                    bit_index += 1
                bit_index += field.decode(binary_str[bit_index:])
            try:
                self._elements[index] = fields
            except IndexError:
                self._elements.append(fields)
        return bit_index

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;The XML representation of the ArrayField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.fixed:
            default = ET.SubElement(xmlfield, &#39;Fixed&#39;)
            default.text = &#39;true&#39;
        fields = ET.SubElement(xmlfield, &#39;Fields&#39;)
        for field in self.fields:
            # assert isinstance(field, FieldCodec)
            fields.append(field.xml())
        return xmlfield


class MessageDefinitions:
    &#34;&#34;&#34;A set of Message Definitions grouped into Services.

    Attributes:
        services: The list of Services with Messages defined.
    
    &#34;&#34;&#34;
    def __init__(self, services: Services = None):
        if services is not None:
            if not isinstance(services, Services):
                raise ValueError(&#39;Invalid Services&#39;)
        self.services = services or Services()
    
    def xml(self, indent: bool = False) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the complete message definitions.
        
        Args:
            indent: If `True` each layer of the XML will indent 2 spaces.

        &#34;&#34;&#34;
        xmsgdef = ET.Element(&#39;MessageDefinition&#39;,
                             attrib={&#39;xmlns:xsd&#39;: XML_NAMESPACE[&#39;xsd&#39;]})
        services = ET.SubElement(xmsgdef, &#39;Services&#39;)
        for service in self.services:
            # assert isinstance(service, ServiceCodec)
            services.append(service.xml())
        return xmsgdef if not indent else _indent_xml(xmsgdef)
    
    def mdf_export(self, filename: str, pretty: bool = False):
        &#34;&#34;&#34;Creates an XML file at the target location.
        
        Args:
            filename: The full path/filename to save to. `.idpmsg` is
                recommended as a file extension.
            pretty: If `True` will indent each layer of the XML by 2 spaces.

        &#34;&#34;&#34;
        tree = ET.ElementTree(self.xml())
        root = tree.getroot()
        if pretty:
            from xml.dom.minidom import parseString
            xmlstr = parseString(ET.tostring(root)).toprettyxml(indent=&#34;  &#34;)
            with open(filename, &#39;w&#39;) as f:
                f.write(xmlstr)
        else:
            with open(filename, &#39;wb&#39;) as f:
                tree.write(f, encoding=&#39;utf-8&#39;, xml_declaration=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="idpmodem.codecs.common_mdf.optimal_bits"><code class="name flex">
<span>def <span class="ident">optimal_bits</span></span>(<span>value_range:Â tuple[int,Â int]) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the optimal number of bits for encoding a specified range.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value_range</code></strong></dt>
<dd>A tuple with the minimum and maximum values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of bits to optimally encode the value.</p>
<h2 id="raises">Raises</h2>
<p>ValueError if the</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimal_bits(value_range: &#39;tuple[int, int]&#39;) -&gt; int:
    &#34;&#34;&#34;Returns the optimal number of bits for encoding a specified range.
    
    Args:
        value_range: A tuple with the minimum and maximum values.
    
    Returns:
        The number of bits to optimally encode the value.
    
    Raises:
        ValueError if the 

    &#34;&#34;&#34;
    if (not isinstance(value_range, tuple) or
        len(value_range) != 2 or
        not all(isinstance(x, int) for x in value_range) or
        value_range[0] &gt;= value_range[1]):
        #: non-compliant
        raise ValueError(&#39;value_range must be of form (min, max)&#39;)
    total_range = value_range[1] - value_range[0]
    total_range += 1 if value_range[0] == 0 else 0
    return max(1, ceil(log2(value_range[1] - value_range[0])))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="idpmodem.codecs.common_mdf.ArrayField"><code class="flex name class">
<span>class <span class="ident">ArrayField</span></span>
<span>(</span><span>name:Â str, size:Â int, fields:Â <a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a>, description:Â strÂ =Â None, optional:Â boolÂ =Â False, fixed:Â boolÂ =Â False, elements:Â list[<a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a>]Â =Â [])</span>
</code></dt>
<dd>
<div class="desc"><p>An Array Field provides a list where each element is a set of Fields.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the field instance.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of elements allowed.</dd>
<dt><strong><code>fields</code></strong> :&ensp;<code><a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a></code></dt>
<dd>A list of Field types comprising each ArrayElement</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional description of the array/use.</dd>
<dt><strong><code>optional</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the array is optional in the Message</dd>
<dt><strong><code>fixed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the array is always the fixed <code>size</code></dd>
<dt><strong><code>elements</code></strong> :&ensp;<code>list</code></dt>
<dd>The enumerated list of ArrayElements</dd>
</dl>
<p>Initializes an ArrayField instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The unique field name within the Message.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The maximum number of elements allowed.</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>The list of Field types comprising each element.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>An optional description/purpose of the array.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>Indicates if the array is optional in the Message.</dd>
<dt><strong><code>fixed</code></strong></dt>
<dd>Indicates if the array is always the fixed <code>size</code>.</dd>
<dt><strong><code>elements</code></strong></dt>
<dd>Option to populate elements of Fields during instantiation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayField(FieldCodec):
    &#34;&#34;&#34;An Array Field provides a list where each element is a set of Fields.
    
    Attributes:
        name (str): The name of the field instance.
        size (int): The maximum number of elements allowed.
        fields (Fields): A list of Field types comprising each ArrayElement
        description (str): An optional description of the array/use.
        optional (bool): Indicates if the array is optional in the Message
        fixed (bool): Indicates if the array is always the fixed `size`
        elements (list): The enumerated list of ArrayElements

    &#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 fields: Fields,
                 description: str = None,
                 optional: bool = False,
                 fixed: bool = False,
                 elements: &#39;list[Fields]&#39; = []) -&gt; None:
        &#34;&#34;&#34;Initializes an ArrayField instance.
        
        Args:
            name: The unique field name within the Message.
            size: The maximum number of elements allowed.
            fields: The list of Field types comprising each element.
            description: An optional description/purpose of the array.
            optional: Indicates if the array is optional in the Message.
            fixed: Indicates if the array is always the fixed `size`.
            elements: Option to populate elements of Fields during instantiation.

        &#34;&#34;&#34;
        super().__init__(name=name,
                         data_type=&#39;array&#39;,
                         description=description,
                         optional=optional)
        self._size = size
        self._fixed = fixed
        self._fields = fields
        self._elements = elements or []
    
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The maximum number of array elements.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0&#39;)
        self._size = value
    
    @property
    def fixed(self) -&gt; bool:
        &#34;&#34;&#34;Indicates if the array is a fixed size (padded with defaults).&#34;&#34;&#34;
        return self._fixed

    @property
    def fields(self) -&gt; Fields:
        &#34;&#34;&#34;The set of `FieldCodec`s that make up each array element.&#34;&#34;&#34;
        return self._fields

    @fields.setter
    def fields(self, fields: Fields):
        if not isinstance(fields, Fields):
            raise ValueError(&#39;Invalid Fields definition for ArrayField&#39;)
        self._fields = fields

    @property
    def elements(self) -&gt; &#39;list[Fields]&#39;:
        &#34;&#34;&#34;The list of elements (field sets) in the array.&#34;&#34;&#34;
        return self._elements
    
    @elements.setter
    def elements(self, elements: &#39;list[Fields]&#39;):
        if (not isinstance(elements, list) or 
            not all(isinstance(item, Fields) for item in elements)):
            raise ValueError(&#39;Elements must be a list of grouped Fields&#39;)
        for fields in elements:
            # assert isinstance(fields, Fields)
            for index, field in enumerate(fields):
                assert isinstance(field, FieldCodec)
                if (field.name != self.fields[index].name):
                    raise ValueError(f&#39;fields[{index}].name&#39;
                                     f&#39; expected {self.fields[index].name}&#39;
                                     f&#39; got {field.name}&#39;)
                if (field.data_type != self.fields[index].data_type):
                    raise ValueError(f&#39;fields[{index}].data_type&#39;
                                     f&#39; expected {self.fields[index].data_type}&#39;
                                     f&#39; got {field.data_type}&#39;)
                #TODO: validate non-optional fields have value/elements
                if (not field.optional and
                    not isinstance(field, ArrayField) and
                    field.value is None):
                    raise ValueError(f&#39;fields[{index}].value missing&#39;)
                try:
                    self._elements[index] = fields
                except IndexError:
                    self._elements.append(fields)

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;The size of the array in bits.&#34;&#34;&#34;
        bits = 0
        for field in self.fields:
            # assert isinstance(field, FieldCodec)
            bits += field.bits
        return bits
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, ArrayField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def _valid_element(self, element: Fields) -&gt; bool:
        for i, field in enumerate(self.fields):
            # assert isinstance(field, FieldCodec)
            e_field = element[i]
            # assert isinstance(e_field, FieldCodec)
            if e_field.name != field.name:
                raise ValueError(f&#39;element field name {e_field.name}&#39;
                                 f&#39; does not match {field.name}&#39;)
            if e_field.data_type != field.data_type:
                raise ValueError(f&#39;element field data_type {e_field.data_type}&#39;
                                 f&#39; does not match {field.data_type}&#39;)
            if e_field.optional != field.optional:
                raise ValueError(f&#39;element optional {e_field.optional}&#39;
                                 f&#39; does not match {field.optional}&#39;)
            if (hasattr(field, &#39;fixed&#39;) and
                hasattr(e_field, &#39;fixed&#39;) and
                e_field.fixed != field.fixed):
                raise ValueError(f&#39;element fixed {e_field.fixed}&#39;
                                 f&#39; does not match {field.fixed}&#39;)
            if (hasattr(field, &#39;size&#39;) and
                hasattr(e_field, &#39;size&#39;) and
                e_field.size != field.size):
                raise ValueError(f&#39;element size {e_field.size}&#39;
                                 f&#39; does not match {field.size}&#39;)
        return True

    def _append(self, element: Fields):
        &#34;&#34;&#34;Adds the array element to the list of elements.&#34;&#34;&#34;
        if not isinstance(element, Fields):
            raise ValueError(&#39;Invalid element definition must be Fields&#39;)
        if self._valid_element(element):
            for i, field in enumerate(element):
                assert isinstance(field, FieldCodec)
                if (hasattr(field, &#39;description&#39;) and
                    field.description != self.fields[i].description):
                    element[i].description = self.fields[i].description
                if hasattr(field, &#39;value&#39;) and field.value is None:
                    element[i].value = self.fields[i].default
            self._elements.append(element)

    def new_element(self) -&gt; Fields:
        &#34;&#34;&#34;Returns an empty element at the end of the elements list.&#34;&#34;&#34;
        new_index = len(self._elements)
        new_fields = deepcopy(self.fields)
        self._append(Fields(new_fields))
        return self.elements[new_index]

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if len(self.elements) == 0:
            raise ValueError(&#39;No elements to encode&#39;)
        binstr = &#39;&#39;
        for element in self.elements:
            for field in element:
                binstr += field.encode()
        if not self.fixed:
            binstr = _encode_field_length(len(self.elements)) + binstr
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        if self.fixed:
            length = self.size
            bit_index = 0
        else:
            (length, bit_index) = _decode_field_length(binary_str)
        for index in range(0, length):
            fields = Fields(self.fields)
            for field in fields:
                if field.optional:
                    if binary_str[bit_index] == &#39;0&#39;:
                        bit_index += 1
                        continue
                    bit_index += 1
                bit_index += field.decode(binary_str[bit_index:])
            try:
                self._elements[index] = fields
            except IndexError:
                self._elements.append(fields)
        return bit_index

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;The XML representation of the ArrayField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.fixed:
            default = ET.SubElement(xmlfield, &#39;Fixed&#39;)
            default.text = &#39;true&#39;
        fields = ET.SubElement(xmlfield, &#39;Fields&#39;)
        for field in self.fields:
            # assert isinstance(field, FieldCodec)
            fields.append(field.xml())
        return xmlfield</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.ArrayField.bits"><code class="name">var <span class="ident">bits</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The size of the array in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self) -&gt; int:
    &#34;&#34;&#34;The size of the array in bits.&#34;&#34;&#34;
    bits = 0
    for field in self.fields:
        # assert isinstance(field, FieldCodec)
        bits += field.bits
    return bits</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ArrayField.elements"><code class="name">var <span class="ident">elements</span> :Â list[<a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a>]</code></dt>
<dd>
<div class="desc"><p>The list of elements (field sets) in the array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self) -&gt; &#39;list[Fields]&#39;:
    &#34;&#34;&#34;The list of elements (field sets) in the array.&#34;&#34;&#34;
    return self._elements</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ArrayField.fields"><code class="name">var <span class="ident">fields</span> :Â <a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a></code></dt>
<dd>
<div class="desc"><p>The set of <code><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></code>s that make up each array element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fields(self) -&gt; Fields:
    &#34;&#34;&#34;The set of `FieldCodec`s that make up each array element.&#34;&#34;&#34;
    return self._fields</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ArrayField.fixed"><code class="name">var <span class="ident">fixed</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Indicates if the array is a fixed size (padded with defaults).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fixed(self) -&gt; bool:
    &#34;&#34;&#34;Indicates if the array is a fixed size (padded with defaults).&#34;&#34;&#34;
    return self._fixed</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ArrayField.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The maximum number of array elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;The maximum number of array elements.&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.ArrayField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, binary_str:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Populates the field value from binary and returns the next offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The binary string to decode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bit offset after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, binary_str: str) -&gt; int:
    &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
    
    Args:
        binary_str (str): The binary string to decode
    
    Returns:
        The bit offset after parsing
    &#34;&#34;&#34;
    if self.fixed:
        length = self.size
        bit_index = 0
    else:
        (length, bit_index) = _decode_field_length(binary_str)
    for index in range(0, length):
        fields = Fields(self.fields)
        for field in fields:
            if field.optional:
                if binary_str[bit_index] == &#39;0&#39;:
                    bit_index += 1
                    continue
                bit_index += 1
            bit_index += field.decode(binary_str[bit_index:])
        try:
            self._elements[index] = fields
        except IndexError:
            self._elements.append(fields)
    return bit_index</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ArrayField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the binary string of the field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; str:
    &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
    if len(self.elements) == 0:
        raise ValueError(&#39;No elements to encode&#39;)
    binstr = &#39;&#39;
    for element in self.elements:
        for field in element:
            binstr += field.encode()
    if not self.fixed:
        binstr = _encode_field_length(len(self.elements)) + binstr
    return binstr</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ArrayField.new_element"><code class="name flex">
<span>def <span class="ident">new_element</span></span>(<span>self) â€‘>Â <a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an empty element at the end of the elements list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_element(self) -&gt; Fields:
    &#34;&#34;&#34;Returns an empty element at the end of the elements list.&#34;&#34;&#34;
    new_index = len(self._elements)
    new_fields = deepcopy(self.fields)
    self._append(Fields(new_fields))
    return self.elements[new_index]</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ArrayField.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>The XML representation of the ArrayField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self) -&gt; ET.Element:
    &#34;&#34;&#34;The XML representation of the ArrayField.&#34;&#34;&#34;
    xmlfield = self._base_xml()
    size = ET.SubElement(xmlfield, &#39;Size&#39;)
    size.text = str(self.size)
    if self.fixed:
        default = ET.SubElement(xmlfield, &#39;Fixed&#39;)
        default.text = &#39;true&#39;
    fields = ET.SubElement(xmlfield, &#39;Fields&#39;)
    for field in self.fields:
        # assert isinstance(field, FieldCodec)
        fields.append(field.xml())
    return xmlfield</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.BaseCodec"><code class="flex name class">
<span>class <span class="ident">BaseCodec</span></span>
<span>(</span><span>name:Â str, description:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseCodec:
    def __init__(self, name: str, description: str = None) -&gt; None:
        if not name or name.strip() == &#39;&#39;:
            raise ValueError(&#39;Invalid name must be non-empty&#39;)
        self._name = name
        self._description = description
    
    @property
    def name(self) -&gt; str:
        return self._name
    
    @property
    def description(self) -&gt; str:
        return self._description
    
    @description.setter
    def description(self, value: str):
        if value is not None and not isinstance(value, str) and not value:
            raise ValueError(&#39;Description must be non-empty string or None&#39;)
        self._description = value</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.MessageCodec" href="#idpmodem.codecs.common_mdf.MessageCodec">MessageCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.ServiceCodec" href="#idpmodem.codecs.common_mdf.ServiceCodec">ServiceCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.BaseCodec.description"><code class="name">var <span class="ident">description</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    return self._description</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.BaseCodec.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.BooleanField"><code class="flex name class">
<span>class <span class="ident">BooleanField</span></span>
<span>(</span><span>name:Â str, description:Â strÂ =Â None, optional:Â boolÂ =Â False, default:Â boolÂ =Â False, value:Â boolÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Boolean field.</p>
<p>Instantiates the base field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The field name must be unique within a Message.</dd>
<dt><strong><code>data_type</code></strong></dt>
<dd>The data type represented within the field.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>(Optional) Description/purpose of the field.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>(Optional) Indicates if the field is mandatory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanField(FieldCodec):
    &#34;&#34;&#34;A Boolean field.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 description: str = None,
                 optional: bool = False,
                 default: bool = False,
                 value: bool = None) -&gt; None:
        super().__init__(name=name,
                         data_type=&#39;bool&#39;,
                         description=description,
                         optional=optional)
        &#34;&#34;&#34;Instantiates a BooleanField.
        
        Args:
            name: The field name must be unique within a Message.
            description: An optional description/purpose for the field.
            optional: Indicates if the field is optional in the Message.
            default: A default value for the boolean.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        self._default = default if isinstance(default, bool) else False
        self._value = value if value is not None else self._default
    
    @property
    def default(self):
        return self._default

    @default.setter
    def default(self, v: bool):
        if v is not None and not isinstance(v, bool):
            raise ValueError(f&#39;Invalid boolean value {v}&#39;)
        self._default = v

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, v: bool):
        if v is not None and not isinstance(v, bool):
            raise ValueError(f&#39;Invalid boolean value {v}&#39;)
        self._value = v

    @property
    def bits(self):
        return 1
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, BooleanField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None and not self.optional:
            raise ValueError(&#39;No value assigned to field&#39;)
        return &#39;1&#39; if self.value else &#39;0&#39;

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        self.value = True if binary_str[0] == &#39;1&#39; else False
        return 1

    def xml(self) -&gt; ET.Element:
        xmlfield = self._base_xml()
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = &#39;true&#39;
        return xmlfield</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.BooleanField.default"><code class="name">var <span class="ident">default</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self):
    return self._default</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.BooleanField.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.BooleanField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, binary_str:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Populates the field value from binary and returns the next offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The binary string to decode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bit offset after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, binary_str: str) -&gt; int:
    &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
    
    Args:
        binary_str (str): The binary string to decode
    
    Returns:
        The bit offset after parsing
    &#34;&#34;&#34;
    self.value = True if binary_str[0] == &#39;1&#39; else False
    return 1</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.BooleanField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the binary string of the field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; str:
    &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
    if self.value is None and not self.optional:
        raise ValueError(&#39;No value assigned to field&#39;)
    return &#39;1&#39; if self.value else &#39;0&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></b></code>:
<ul class="hlist">
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.bits" href="#idpmodem.codecs.common_mdf.FieldCodec.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.xml" href="#idpmodem.codecs.common_mdf.FieldCodec.xml">xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="idpmodem.codecs.common_mdf.CodecList"><code class="flex name class">
<span>class <span class="ident">CodecList</span></span>
<span>(</span><span>codec_cls:Â object)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for a specific object type list.</p>
<p>Used for Fields, Messages, Services.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>codec_cls</code></strong></dt>
<dd>The object type the list is comprised of.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CodecList(list):
    &#34;&#34;&#34;Base class for a specific object type list.
    
    Used for Fields, Messages, Services.

    Attributes:
        codec_cls: The object type the list is comprised of.

    &#34;&#34;&#34;
    def __init__(self, codec_cls: object):
        super().__init__()
        self.list_type = codec_cls

    def add(self, obj: object) -&gt; bool:
        &#34;&#34;&#34;Add an object to the end of the list.

        Args:
            obj (object): A valid object according to the list_type
        
        Raises:
            ValueError if there is a duplicate or invalid name,
                invalid value_range or unsupported data_type
        &#34;&#34;&#34;
        if not isinstance(obj, self.list_type):
            raise ValueError(f&#39;Invalid {self.list_type} definition&#39;)
        for o in self:
            if o.name == obj.name:
                raise ValueError(f&#39;Duplicate {self.list_type}&#39;
                                 f&#39; name {obj.name} found&#39;)
        self.append(obj)
        return True

    def __getitem__(self, n: &#39;str|int&#39;) -&gt; object:
        &#34;&#34;&#34;Retrieves an object by name or index.
        
        Args:
            n: The object name or list index
        
        Returns:
            object

        &#34;&#34;&#34;
        if isinstance(n, str):
            for o in self:
                if o.name == n:
                    return o
            raise ValueError(f&#39;{self.list_type} name {n} not found&#39;)
        return super().__getitem__(n)

    def __setitem__(self, n: &#39;str|int&#39;, value):
        if isinstance(n, str):
            for o in self:
                if o.name == n:
                    o.value = value
                    break
        else:
            super().__setitem__(n, value)

    def delete(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Delete an object from the list by name.
        
        Args:
            name: The name of the object.

        Returns:
            boolean: success
        &#34;&#34;&#34;
        for o in self:
            if o.name == name:
                self.remove(o)
                return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.list</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a></li>
<li><a title="idpmodem.codecs.common_mdf.Messages" href="#idpmodem.codecs.common_mdf.Messages">Messages</a></li>
<li><a title="idpmodem.codecs.common_mdf.Services" href="#idpmodem.codecs.common_mdf.Services">Services</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.CodecList.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, obj:Â object) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Add an object to the end of the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>object</code></dt>
<dd>A valid object according to the list_type</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError if there is a duplicate or invalid name,
invalid value_range or unsupported data_type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, obj: object) -&gt; bool:
    &#34;&#34;&#34;Add an object to the end of the list.

    Args:
        obj (object): A valid object according to the list_type
    
    Raises:
        ValueError if there is a duplicate or invalid name,
            invalid value_range or unsupported data_type
    &#34;&#34;&#34;
    if not isinstance(obj, self.list_type):
        raise ValueError(f&#39;Invalid {self.list_type} definition&#39;)
    for o in self:
        if o.name == obj.name:
            raise ValueError(f&#39;Duplicate {self.list_type}&#39;
                             f&#39; name {obj.name} found&#39;)
    self.append(obj)
    return True</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.CodecList.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, name:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an object from the list by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>success</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Delete an object from the list by name.
    
    Args:
        name: The name of the object.

    Returns:
        boolean: success
    &#34;&#34;&#34;
    for o in self:
        if o.name == name:
            self.remove(o)
            return True
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField"><code class="flex name class">
<span>class <span class="ident">DataField</span></span>
<span>(</span><span>name:Â str, size:Â int, data_type:Â strÂ =Â 'data', precision:Â intÂ =Â None, description:Â strÂ =Â None, optional:Â boolÂ =Â False, fixed:Â boolÂ =Â False, default:Â bytesÂ =Â None, value:Â bytesÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A data field of raw bytes sent over-the-air.</p>
<p>Can also be used to hold floating point, double-precision or large integers.</p>
<p>Instantiates a EnumField.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The field name must be unique within a Message.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The maximum number of bytes to send over-the-air.</dd>
<dt><strong><code>data_type</code></strong></dt>
<dd>The data type represented within the bytes.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>An optional description/purpose for the field.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>Indicates if the field is optional in the Message.</dd>
<dt><strong><code>fixed</code></strong></dt>
<dd>Indicates if the data bytes are a fixed <code>size</code>.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>A default value for the enum.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Optional value to set during initialization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataField(FieldCodec):
    &#34;&#34;&#34;A data field of raw bytes sent over-the-air.
    
    Can also be used to hold floating point, double-precision or large integers.

    &#34;&#34;&#34;
    SUPPORTED_DATA_TYPES = [&#39;data&#39;, &#39;float&#39;, &#39;double&#39;]
    def __init__(self,
                 name: str,
                 size: int,
                 data_type: str = &#39;data&#39;,
                 precision: int = None,
                 description: str = None,
                 optional: bool = False,
                 fixed: bool = False,
                 default: bytes = None,
                 value: bytes = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a EnumField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The maximum number of bytes to send over-the-air.
            data_type: The data type represented within the bytes.
            description: An optional description/purpose for the field.
            optional: Indicates if the field is optional in the Message.
            fixed: Indicates if the data bytes are a fixed `size`.
            default: A default value for the enum.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        if data_type is None or data_type not in self.SUPPORTED_DATA_TYPES:
            raise ValueError(f&#39;Invalid data type {data_type}&#39;)
        super().__init__(name=name,
                         data_type=data_type,
                         description=description,
                         optional=optional)
        self._fixed = fixed
        self._size = size
        self._default = default
        self._precision = precision
        self._value = self._default
        if value:
            self.value = value
    
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The maximum size of the field in bytes.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bytes&#39;)
        if self.data_type == &#39;float&#39;:
            if value != 4:
                warn(&#39;Adjusting float size to 4 bytes fixed&#39;)
            self._size = 4
            self.fixed = True
        elif self.data_type == &#39;double&#39;:
            if value != 8:
                warn(&#39;Adjusting double size to 8 bytes fixed&#39;)
            self._size = 8
            self.fixed = True
        else:
            self._size = value
    
    def _validate_data(self, v: &#39;bytes|float&#39;) -&gt; bytes:
        &#34;&#34;&#34;Ensures the data is of the target field size and encoding.&#34;&#34;&#34;
        data_type = self.data_type
        if not ((isinstance(v, bytes) and data_type == &#39;data&#39;) or
                (isinstance(v, float) and data_type in [&#39;float&#39;, &#39;double&#39;])):
            raise ValueError(f&#39;Data {type(v)} does not match {data_type}&#39;)
        if data_type in [&#39;float&#39;, &#39;double&#39;]:
            _format = &#39;!f&#39; if data_type == &#39;float&#39; else &#39;!d&#39;
            v = pack(_format, v)
        assert isinstance(v, bytes)
        if self.fixed:
            if len(v) &gt; self.size:
                warn(f&#39;Truncating data to {self.size} bytes&#39;)
                return v[0:self.size]
            elif len(v) &lt; self.size:
                warn(f&#39;Padding data to {self.size} bytes&#39;)
                return v.ljust(self.size, b&#39;\0&#39;)
        return v

    def _convert_to_float(self, v: bytes) -&gt; &#39;float|None&#39;:
        if not self.data_type in (&#39;float&#39;, &#39;double&#39;):
            return None
        convertor = &#39;!f&#39; if self.data_type == &#39;float&#39; else &#39;!d&#39;
        converted = unpack(convertor, v)[0]
        if self.precision:
            converted = round(converted, self.precision)
        return converted

    @property
    def default(self) -&gt; &#39;bytes|float&#39;:
        &#34;&#34;&#34;The default value, converted for float or double data types.&#34;&#34;&#34;
        if self.data_type in [&#39;float&#39;, &#39;double&#39;]:
            return self._convert_to_float(self._default)
        return self._default
    
    @default.setter
    def default(self, v: &#39;bytes|float&#39;):
        self._default = self._validate_data(v)

    @property
    def precision(self) -&gt; &#39;int|None&#39;:
        &#34;&#34;&#34;The number of decimal places for `float` or `double` data types.&#34;&#34;&#34;
        return self._precision

    @property
    def converted_value(self) -&gt; &#39;float|None&#39;:
        &#34;&#34;&#34;The converted value for `float` and `double` data types.&#34;&#34;&#34;
        return self._convert_to_float(self._value)
    
    @property
    def value(self):
        &#34;&#34;&#34;The raw binary value.&#34;&#34;&#34;
        return self._value

    @value.setter
    def value(self, v: &#39;bytes|float&#39;):
        self._value = self._validate_data(v)

    @property
    def fixed(self) -&gt; bool:
        &#34;&#34;&#34;Indicates if the field is fixed size (padded/truncated).&#34;&#34;&#34;
        return self._fixed

    @property
    def bits(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        if self.fixed:
            return self.size * 8
        elif self._value is None:
            return 0
        return len(self._value) * 8
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, DataField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None and not self.optional:
            raise ValueError(f&#39;No value defined for DataField {self.name}&#39;)
        binstr = &#39;&#39;
        binstr = &#39;&#39;.join(format(b, &#39;08b&#39;) for b in self._value)
        if self.fixed:   #:pad to fixed length
            binstr += &#39;&#39;.join(&#39;0&#39; for bit in range(len(binstr), self.bits))
        else:
            binstr = _encode_field_length(len(self._value)) + binstr
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        if self.fixed:
            binary = binary_str[:self.bits]
            bits = self.bits
        else:
            (length, bit_index) = _decode_field_length(binary_str)
            binary = binary_str[bit_index:length * 8 + bit_index]
            bits = len(binary)
        self._value = int(binary, 2).to_bytes(int(bits / 8), &#39;big&#39;)
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;The XML structure of the DataField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.DataField.SUPPORTED_DATA_TYPES"><code class="name">var <span class="ident">SUPPORTED_DATA_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.DataField.bits"><code class="name">var <span class="ident">bits</span></code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self):
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    if self.fixed:
        return self.size * 8
    elif self._value is None:
        return 0
    return len(self._value) * 8</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.converted_value"><code class="name">var <span class="ident">converted_value</span> :Â float|None</code></dt>
<dd>
<div class="desc"><p>The converted value for <code>float</code> and <code>double</code> data types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def converted_value(self) -&gt; &#39;float|None&#39;:
    &#34;&#34;&#34;The converted value for `float` and `double` data types.&#34;&#34;&#34;
    return self._convert_to_float(self._value)</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.default"><code class="name">var <span class="ident">default</span> :Â bytes|float</code></dt>
<dd>
<div class="desc"><p>The default value, converted for float or double data types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self) -&gt; &#39;bytes|float&#39;:
    &#34;&#34;&#34;The default value, converted for float or double data types.&#34;&#34;&#34;
    if self.data_type in [&#39;float&#39;, &#39;double&#39;]:
        return self._convert_to_float(self._default)
    return self._default</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.fixed"><code class="name">var <span class="ident">fixed</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Indicates if the field is fixed size (padded/truncated).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fixed(self) -&gt; bool:
    &#34;&#34;&#34;Indicates if the field is fixed size (padded/truncated).&#34;&#34;&#34;
    return self._fixed</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.precision"><code class="name">var <span class="ident">precision</span> :Â int|None</code></dt>
<dd>
<div class="desc"><p>The number of decimal places for <code>float</code> or <code>double</code> data types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def precision(self) -&gt; &#39;int|None&#39;:
    &#34;&#34;&#34;The number of decimal places for `float` or `double` data types.&#34;&#34;&#34;
    return self._precision</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The maximum size of the field in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;The maximum size of the field in bytes.&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>The raw binary value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    &#34;&#34;&#34;The raw binary value.&#34;&#34;&#34;
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.DataField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, binary_str:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Populates the field value from binary and returns the next offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The binary string to decode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bit offset after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, binary_str: str) -&gt; int:
    &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
    
    Args:
        binary_str (str): The binary string to decode
    
    Returns:
        The bit offset after parsing
    &#34;&#34;&#34;
    if self.fixed:
        binary = binary_str[:self.bits]
        bits = self.bits
    else:
        (length, bit_index) = _decode_field_length(binary_str)
        binary = binary_str[bit_index:length * 8 + bit_index]
        bits = len(binary)
    self._value = int(binary, 2).to_bytes(int(bits / 8), &#39;big&#39;)
    return self.bits</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the binary string of the field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; str:
    &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
    if self.value is None and not self.optional:
        raise ValueError(f&#39;No value defined for DataField {self.name}&#39;)
    binstr = &#39;&#39;
    binstr = &#39;&#39;.join(format(b, &#39;08b&#39;) for b in self._value)
    if self.fixed:   #:pad to fixed length
        binstr += &#39;&#39;.join(&#39;0&#39; for bit in range(len(binstr), self.bits))
    else:
        binstr = _encode_field_length(len(self._value)) + binstr
    return binstr</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.DataField.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>The XML structure of the DataField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self) -&gt; ET.Element:
    &#34;&#34;&#34;The XML structure of the DataField.&#34;&#34;&#34;
    xmlfield = self._base_xml()
    size = ET.SubElement(xmlfield, &#39;Size&#39;)
    size.text = str(self.size)
    if self.default:
        default = ET.SubElement(xmlfield, &#39;Default&#39;)
        default.text = str(self.default)
    return xmlfield</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.EnumField"><code class="flex name class">
<span>class <span class="ident">EnumField</span></span>
<span>(</span><span>name:Â str, items:Â list[str], size:Â int, description:Â strÂ =Â None, optional:Â boolÂ =Â False, default:Â intÂ =Â None, value:Â intÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumerated field sends an index over-the-air representing a string.</p>
<p>Instantiates a EnumField.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The field name must be unique within a Message.</dd>
<dt><strong><code>items</code></strong></dt>
<dd>A list of strings (indexed from 0).</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The number of <em>bits</em> used to encode the index over-the-air.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>An optional description/purpose for the field.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>Indicates if the field is optional in the Message.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>A default value for the enum.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Optional value to set during initialization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumField(FieldCodec):
    &#34;&#34;&#34;An enumerated field sends an index over-the-air representing a string.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 items: &#39;list[str]&#39;,
                 size: int,
                 description: str = None,
                 optional: bool = False,
                 default: int = None,
                 value: int = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a EnumField.
        
        Args:
            name: The field name must be unique within a Message.
            items: A list of strings (indexed from 0).
            size: The number of *bits* used to encode the index over-the-air.
            description: An optional description/purpose for the field.
            optional: Indicates if the field is optional in the Message.
            default: A default value for the enum.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        super().__init__(name=name,
                         data_type=&#39;enum&#39;,
                         description=description,
                         optional=optional)
        if (not isinstance(items, list) or
            not all(isinstance(item, str) for item in items)):
            raise ValueError(&#39;Items must a list of strings&#39;)
        if not isinstance(size, int) or size &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bits&#39;)
        self._items = items
        self._size = size
        self._default = (default if default in range(0, len(self._items))
                         else None)
        self._value = value if value is not None else self._default
    
    def _validate_enum(self, v: &#39;int|str&#39;) -&gt; &#39;int|None&#39;:
        if v is not None:
            if isinstance(v, str):
                if v not in self.items:
                    raise ValueError(f&#39;Invalid value {v}&#39;)
                for index, item in enumerate(self.items):
                    if item == v:
                        return index
            elif isinstance(v, int):
                if v &lt; 0 or v &gt;= len(self.items):
                    raise ValueError(f&#39;Invalid enum index {v}&#39;)
            else:
                raise ValueError(f&#39;Invalid value {v}&#39;)
        return v

    @property
    def items(self):
        return self._items
    
    @items.setter
    def items(self, l: list):
        if not isinstance(l, list) or not all(isinstance(x, str) for x in l):
            raise ValueError(&#39;Items must be a list of strings&#39;)
        self._items = l

    @property
    def default(self) -&gt; str:
        if self._default is None:
            return None
        return self.items[self._default]
    
    @default.setter
    def default(self, v: &#39;int|str&#39;):
        self._default = self._validate_enum(v)

    @property
    def value(self) -&gt; str:
        if self._value is None:
            return None
        return self.items[self._value]
    
    @value.setter
    def value(self, v: &#39;int|str&#39;):
        self._value = self._validate_enum(v)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, v: int):
        if not isinstance(v, int) or v &lt; 1:
            raise ValueError(&#39;Size must be integer greater than zero&#39;)
        minimum_bits = optimal_bits((0, len(self.items)))
        if v &lt; minimum_bits:
            raise ValueError(f&#39;Size must be at least {minimum_bits}&#39;
                             &#39; to support item count&#39;)
        self._size = v

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self.size
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, EnumField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None:
            raise ValueError(f&#39;No value configured in EnumField {self.name}&#39;)
        _format = f&#39;0{self.bits}b&#39;
        binstr = format(self.items.index(self.value), _format)
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        self.value = binary_str[:self.bits]
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the EnumField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        items = ET.SubElement(xmlfield, &#39;Items&#39;)
        for string in self.items:
            item = ET.SubElement(items, &#39;string&#39;)
            item.text = str(string)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.EnumField.bits"><code class="name">var <span class="ident">bits</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self) -&gt; int:
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    return self.size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.EnumField.default"><code class="name">var <span class="ident">default</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self) -&gt; str:
    if self._default is None:
        return None
    return self.items[self._default]</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.EnumField.items"><code class="name">var <span class="ident">items</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def items(self):
    return self._items</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.EnumField.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.EnumField.value"><code class="name">var <span class="ident">value</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; str:
    if self._value is None:
        return None
    return self.items[self._value]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.EnumField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, binary_str:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Populates the field value from binary and returns the next offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The binary string to decode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bit offset after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, binary_str: str) -&gt; int:
    &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
    
    Args:
        binary_str (str): The binary string to decode
    
    Returns:
        The bit offset after parsing
    &#34;&#34;&#34;
    self.value = binary_str[:self.bits]
    return self.bits</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.EnumField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the binary string of the field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; str:
    &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
    if self.value is None:
        raise ValueError(f&#39;No value configured in EnumField {self.name}&#39;)
    _format = f&#39;0{self.bits}b&#39;
    binstr = format(self.items.index(self.value), _format)
    return binstr</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.EnumField.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the XML structure of the EnumField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self) -&gt; ET.Element:
    &#34;&#34;&#34;Gets the XML structure of the EnumField.&#34;&#34;&#34;
    xmlfield = self._base_xml()
    size = ET.SubElement(xmlfield, &#39;Size&#39;)
    size.text = str(self.size)
    items = ET.SubElement(xmlfield, &#39;Items&#39;)
    for string in self.items:
        item = ET.SubElement(items, &#39;string&#39;)
        item.text = str(string)
    if self.default:
        default = ET.SubElement(xmlfield, &#39;Default&#39;)
        default.text = str(self.default)
    return xmlfield</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.FieldCodec"><code class="flex name class">
<span>class <span class="ident">FieldCodec</span></span>
<span>(</span><span>name:Â str, data_type:Â str, description:Â strÂ =Â None, optional:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for a Field.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The data type from a supported list.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The unique Field name.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional description.</dd>
<dt><strong><code>optional</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional indication the field is optional.</dd>
</dl>
<p>Instantiates the base field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The field name must be unique within a Message.</dd>
<dt><strong><code>data_type</code></strong></dt>
<dd>The data type represented within the field.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>(Optional) Description/purpose of the field.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>(Optional) Indicates if the field is mandatory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldCodec(BaseCodec):
    &#34;&#34;&#34;The base class for a Field.
    
    Attributes:
        data_type (str): The data type from a supported list.
        name (str): The unique Field name.
        description (str): Optional description.
        optional (bool): Optional indication the field is optional.

    &#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 data_type: str,
                 description: str = None,
                 optional: bool = False) -&gt; None:
        &#34;&#34;&#34;Instantiates the base field.
        
        Args:
            name: The field name must be unique within a Message.
            data_type: The data type represented within the field.
            description: (Optional) Description/purpose of the field.
            optional: (Optional) Indicates if the field is mandatory.
            
        &#34;&#34;&#34;
        super().__init__(name, description)
        if data_type not in DATA_TYPES:
            raise ValueError(f&#39;Invalid data type {data_type}&#39;)
        self._data_type = data_type
        self._optional = optional
    
    @property
    def data_type(self) -&gt; str:
        return self._data_type

    @property
    def optional(self) -&gt; bool:
        return self._optional
    
    @optional.setter
    def optional(self, value: bool):
        if not value or not isinstance(value, bool):
            value = False
        self._optional = value

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define bits&#39;)

    def __eq__(self, other: object) -&gt; bool:
        &#34;&#34;&#34;Must be subclassed.
        
        Args:
            other: The other thing being compared to this.

        &#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define equivalence&#39;)

    def __repr__(self) -&gt; str:
        rep = {}
        for name in dir(self):
            if name.startswith((&#39;__&#39;, &#39;_&#39;)):
                continue
            attr = getattr(self, name)
            if not callable(attr):
                rep[name] = attr
        return repr(rep)
    
    def _base_xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;The default XML template for a Field.&#34;&#34;&#34;
        xsi_type = DATA_TYPES[self.data_type]
        xmlfield = ET.Element(&#39;Field&#39;, attrib={
            &#39;{http://www.w3.org/2001/XMLSchema-instance}type&#39;: xsi_type
        })
        name = ET.SubElement(xmlfield, &#39;Name&#39;)
        name.text = self.name
        if self.description:
            description = ET.SubElement(xmlfield, &#39;Description&#39;)
            description.text = str(self.description)
        if self.optional:
            optional = ET.SubElement(xmlfield, &#39;Optional&#39;)
            optional.text = &#39;true&#39;
        return xmlfield
    
    def decode(self, *args, **kwargs):
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define decode&#39;)
    
    def encode(self, *args, **kwargs):
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define encode&#39;)
    
    def xml(self, *args, **kwargs):
        &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclass must define xml structure&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.ArrayField" href="#idpmodem.codecs.common_mdf.ArrayField">ArrayField</a></li>
<li><a title="idpmodem.codecs.common_mdf.BooleanField" href="#idpmodem.codecs.common_mdf.BooleanField">BooleanField</a></li>
<li><a title="idpmodem.codecs.common_mdf.DataField" href="#idpmodem.codecs.common_mdf.DataField">DataField</a></li>
<li><a title="idpmodem.codecs.common_mdf.EnumField" href="#idpmodem.codecs.common_mdf.EnumField">EnumField</a></li>
<li><a title="idpmodem.codecs.common_mdf.SignedIntField" href="#idpmodem.codecs.common_mdf.SignedIntField">SignedIntField</a></li>
<li><a title="idpmodem.codecs.common_mdf.StringField" href="#idpmodem.codecs.common_mdf.StringField">StringField</a></li>
<li><a title="idpmodem.codecs.common_mdf.UnsignedIntField" href="#idpmodem.codecs.common_mdf.UnsignedIntField">UnsignedIntField</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.FieldCodec.bits"><code class="name">var <span class="ident">bits</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Must be subclassed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self) -&gt; int:
    &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
    raise NotImplementedError(&#39;Subclass must define bits&#39;)</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.FieldCodec.data_type"><code class="name">var <span class="ident">data_type</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_type(self) -&gt; str:
    return self._data_type</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.FieldCodec.optional"><code class="name">var <span class="ident">optional</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def optional(self) -&gt; bool:
    return self._optional</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.FieldCodec.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Must be subclassed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, *args, **kwargs):
    &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
    raise NotImplementedError(&#39;Subclass must define decode&#39;)</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.FieldCodec.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Must be subclassed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, *args, **kwargs):
    &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
    raise NotImplementedError(&#39;Subclass must define encode&#39;)</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.FieldCodec.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Must be subclassed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self, *args, **kwargs):
    &#34;&#34;&#34;Must be subclassed.&#34;&#34;&#34;
    raise NotImplementedError(&#39;Subclass must define xml structure&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.Fields"><code class="flex name class">
<span>class <span class="ident">Fields</span></span>
<span>(</span><span>fields:Â list[<a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a>]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>The list of Fields defining a Message or ArrayElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fields(CodecList):
    &#34;&#34;&#34;The list of Fields defining a Message or ArrayElement.&#34;&#34;&#34;
    def __init__(self, fields: &#39;list[FieldCodec]&#39; = None):
        super().__init__(codec_cls=FieldCodec)
        if fields is not None:
            for field in fields:
                self.add(field)
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, Fields):
            return NotImplemented
        if len(self) != len(other):
            return False
        for i, field in enumerate(self):
            if field != other[i]:
                return False
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.CodecList" href="#idpmodem.codecs.common_mdf.CodecList">CodecList</a></li>
<li>builtins.list</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="idpmodem.codecs.common_mdf.CodecList" href="#idpmodem.codecs.common_mdf.CodecList">CodecList</a></b></code>:
<ul class="hlist">
<li><code><a title="idpmodem.codecs.common_mdf.CodecList.add" href="#idpmodem.codecs.common_mdf.CodecList.add">add</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.CodecList.delete" href="#idpmodem.codecs.common_mdf.CodecList.delete">delete</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageCodec"><code class="flex name class">
<span>class <span class="ident">MessageCodec</span></span>
<span>(</span><span>name:Â str, sin:Â int, min:Â int, description:Â strÂ =Â None, is_forward:Â boolÂ =Â False, fields:Â <a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a>Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Payload structure for Message Definition Files uploaded to a Mailbox.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The message name</dd>
<dt><strong><code>sin</code></strong> :&ensp;<code>int</code></dt>
<dd>The Service Identification Number</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>int</code></dt>
<dd>The Message Identification Number</dd>
<dt><strong><code>fields</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of Fields</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional description</dd>
<dt><strong><code>is_forward</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the message is mobile-terminated</dd>
</dl>
<p>Instantiates a Message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The message name should be unique within the xMessages list.</dd>
<dt><strong><code>sin</code></strong></dt>
<dd>The Service Identification Number (16..255)</dd>
<dt><strong><code>min</code></strong></dt>
<dd>The Message Identification Number (0..255)</dd>
<dt><strong><code>description</code></strong></dt>
<dd>(Optional) Description/purpose of the Message.</dd>
<dt><strong><code>is_forward</code></strong></dt>
<dd>Indicates if the message is intended to be
Mobile-Terminated.</dd>
<dt><strong><code>fields</code></strong></dt>
<dd>Optional definition of fields during instantiation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageCodec(BaseCodec):
    &#34;&#34;&#34;The Payload structure for Message Definition Files uploaded to a Mailbox.
    
    Attributes:
        name (str): The message name
        sin (int): The Service Identification Number
        min (int): The Message Identification Number
        fields (list): A list of Fields
        description (str): Optional description
        is_forward (bool): Indicates if the message is mobile-terminated

    &#34;&#34;&#34;

    def __init__(self,
                 name: str,
                 sin: int,
                 min: int,
                 description: str = None,
                 is_forward: bool = False,
                 fields: Fields = None):
        &#34;&#34;&#34;Instantiates a Message.
        
        Args:
            name: The message name should be unique within the xMessages list.
            sin: The Service Identification Number (16..255)
            min: The Message Identification Number (0..255)
            description: (Optional) Description/purpose of the Message.
            is_forward: Indicates if the message is intended to be
                Mobile-Terminated.
            fields: Optional definition of fields during instantiation.

        &#34;&#34;&#34;
        if not isinstance(sin, int) or sin not in range(16, 256):
            raise ValueError(f&#39;Invalid SIN {sin} must be in range 16..255&#39;)
        if not isinstance(min, int) or min not in range (0, 256):
            raise ValueError(f&#39;Invalid MIN {min} must be in range 0..255&#39;)
        super().__init__(name, description)
        self._is_forward = is_forward
        self._sin = sin
        self._min = min
        self._fields: Fields = fields or Fields()

    @property
    def is_forward(self) -&gt; bool:
        return self._is_forward
    
    @property
    def sin(self) -&gt; int:
        return self._sin

    @property
    def min(self) -&gt; int:
        return self._min

    @property
    def fields(self) -&gt; Fields:
        return self._fields
    
    @fields.setter
    def fields(self, fields: Fields):
        if not all(isinstance(field, FieldCodec) for field in fields):
            raise ValueError(&#39;Invalid field found in list&#39;)
        self._fields = fields

    @property
    def ota_size(self) -&gt; int:
        ota_bits = 2 * 8
        for field in self.fields:
            assert isinstance(field, FieldCodec)
            ota_bits += field.bits + (1 if field.optional else 0)
        return ceil(ota_bits / 8)

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, MessageCodec):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def decode(self, databytes: bytes) -&gt; None:
        &#34;&#34;&#34;Parses and stores field values from raw data (received over-the-air).
        
        Args:
            databytes: A bytes array (typically from the forward message)
        &#34;&#34;&#34;
        binary_str = &#39;&#39;.join(format(int(b), &#39;08b&#39;) for b in databytes)
        bit_offset = 16   #: Begin after SIN/MIN bytes
        for field in self.fields:
            assert isinstance(field, FieldCodec)
            if field.optional:
                present = binary_str[bit_offset] == &#39;1&#39;
                bit_offset += 1
                if not present:
                    continue
            bit_offset += field.decode(binary_str[bit_offset:])

    def encode(self,
               data_format: int = DataFormat.BASE64,
               exclude: list = None) -&gt; dict:
        &#34;&#34;&#34;Encodes using the specified data format (base64 or hex).

        Args:
            data_format (int): 2=ASCII-Hex, 3=base64
            exclude (list[str]): A list of optional field names to exclude
        
        Returns:
            Dictionary with sin, min, data_format and data to pass into AT%MGRT
                or atcommand function `message_mo_send`
        &#34;&#34;&#34;
        if data_format not in [DataFormat.BASE64, DataFormat.HEX]:
            raise ValueError(f&#39;data_format {data_format} unsupported&#39;)
        bin_str = &#39;&#39;
        for field in self.fields:
            assert isinstance(field, FieldCodec)
            if field.optional:
                if exclude is not None and field.name in exclude:
                    present = False
                elif hasattr(field, &#39;value&#39;):
                    present = field.value is not None
                elif hasattr(field, &#39;elements&#39;):
                    present = field.elements is not None
                else:
                    raise ValueError(&#39;Unknown value of optional&#39;)
                bin_str += &#39;1&#39; if present else &#39;0&#39;
                if not present:
                    continue
            bin_str += field.encode()
        for _ in range(0, 8 - len(bin_str) % 8):   #:pad to next byte
            bin_str += &#39;0&#39;
        _format = f&#39;0{int(len(bin_str) / 8 * 2)}X&#39;   #:hex bytes 2 chars
        hex_str = format(int(bin_str, 2), _format)
        if (self.is_forward and len(hex_str) / 2 &gt; 9998 or
            not self.is_forward and len(hex_str) / 2 &gt; 6398):
            raise ValueError(f&#39;{len(hex_str) / 2} bytes exceeds maximum size&#39;
                             &#39; for Payload&#39;)
        if data_format == DataFormat.HEX:
            data = hex_str
        else:
            data = b2a_base64(bytearray.fromhex(hex_str)).strip().decode()
        return {
            &#39;sin&#39;: self.sin,
            &#39;min&#39;: self.min,
            &#39;data_format&#39;: data_format,
            &#39;data&#39;: data
        }

    def xml(self, indent: bool = False) -&gt; ET.Element:
        &#34;&#34;&#34;Returns the XML definition for a Message Definition File.&#34;&#34;&#34;
        xmessage = ET.Element(&#39;Message&#39;)
        name = ET.SubElement(xmessage, &#39;Name&#39;)
        name.text = self.name
        min = ET.SubElement(xmessage, &#39;MIN&#39;)
        min.text = str(self.min)
        fields = ET.SubElement(xmessage, &#39;Fields&#39;)
        for field in self.fields:
            fields.append(field.xml())
        return xmessage if not indent else _indent_xml(xmessage)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.fields"><code class="name">var <span class="ident">fields</span> :Â <a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fields(self) -&gt; Fields:
    return self._fields</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.is_forward"><code class="name">var <span class="ident">is_forward</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_forward(self) -&gt; bool:
    return self._is_forward</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.min"><code class="name">var <span class="ident">min</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min(self) -&gt; int:
    return self._min</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.ota_size"><code class="name">var <span class="ident">ota_size</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ota_size(self) -&gt; int:
    ota_bits = 2 * 8
    for field in self.fields:
        assert isinstance(field, FieldCodec)
        ota_bits += field.bits + (1 if field.optional else 0)
    return ceil(ota_bits / 8)</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.sin"><code class="name">var <span class="ident">sin</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sin(self) -&gt; int:
    return self._sin</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, databytes:Â bytes) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Parses and stores field values from raw data (received over-the-air).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>databytes</code></strong></dt>
<dd>A bytes array (typically from the forward message)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, databytes: bytes) -&gt; None:
    &#34;&#34;&#34;Parses and stores field values from raw data (received over-the-air).
    
    Args:
        databytes: A bytes array (typically from the forward message)
    &#34;&#34;&#34;
    binary_str = &#39;&#39;.join(format(int(b), &#39;08b&#39;) for b in databytes)
    bit_offset = 16   #: Begin after SIN/MIN bytes
    for field in self.fields:
        assert isinstance(field, FieldCodec)
        if field.optional:
            present = binary_str[bit_offset] == &#39;1&#39;
            bit_offset += 1
            if not present:
                continue
        bit_offset += field.decode(binary_str[bit_offset:])</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, data_format:Â intÂ =Â DataFormat.BASE64, exclude:Â listÂ =Â None) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes using the specified data format (base64 or hex).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_format</code></strong> :&ensp;<code>int</code></dt>
<dd>2=ASCII-Hex, 3=base64</dd>
<dt><strong><code>exclude</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of optional field names to exclude</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary with sin, min, data_format and data to pass into AT%MGRT
or atcommand function <code>message_mo_send</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self,
           data_format: int = DataFormat.BASE64,
           exclude: list = None) -&gt; dict:
    &#34;&#34;&#34;Encodes using the specified data format (base64 or hex).

    Args:
        data_format (int): 2=ASCII-Hex, 3=base64
        exclude (list[str]): A list of optional field names to exclude
    
    Returns:
        Dictionary with sin, min, data_format and data to pass into AT%MGRT
            or atcommand function `message_mo_send`
    &#34;&#34;&#34;
    if data_format not in [DataFormat.BASE64, DataFormat.HEX]:
        raise ValueError(f&#39;data_format {data_format} unsupported&#39;)
    bin_str = &#39;&#39;
    for field in self.fields:
        assert isinstance(field, FieldCodec)
        if field.optional:
            if exclude is not None and field.name in exclude:
                present = False
            elif hasattr(field, &#39;value&#39;):
                present = field.value is not None
            elif hasattr(field, &#39;elements&#39;):
                present = field.elements is not None
            else:
                raise ValueError(&#39;Unknown value of optional&#39;)
            bin_str += &#39;1&#39; if present else &#39;0&#39;
            if not present:
                continue
        bin_str += field.encode()
    for _ in range(0, 8 - len(bin_str) % 8):   #:pad to next byte
        bin_str += &#39;0&#39;
    _format = f&#39;0{int(len(bin_str) / 8 * 2)}X&#39;   #:hex bytes 2 chars
    hex_str = format(int(bin_str, 2), _format)
    if (self.is_forward and len(hex_str) / 2 &gt; 9998 or
        not self.is_forward and len(hex_str) / 2 &gt; 6398):
        raise ValueError(f&#39;{len(hex_str) / 2} bytes exceeds maximum size&#39;
                         &#39; for Payload&#39;)
    if data_format == DataFormat.HEX:
        data = hex_str
    else:
        data = b2a_base64(bytearray.fromhex(hex_str)).strip().decode()
    return {
        &#39;sin&#39;: self.sin,
        &#39;min&#39;: self.min,
        &#39;data_format&#39;: data_format,
        &#39;data&#39;: data
    }</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageCodec.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self, indent:Â boolÂ =Â False) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the XML definition for a Message Definition File.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self, indent: bool = False) -&gt; ET.Element:
    &#34;&#34;&#34;Returns the XML definition for a Message Definition File.&#34;&#34;&#34;
    xmessage = ET.Element(&#39;Message&#39;)
    name = ET.SubElement(xmessage, &#39;Name&#39;)
    name.text = self.name
    min = ET.SubElement(xmessage, &#39;MIN&#39;)
    min.text = str(self.min)
    fields = ET.SubElement(xmessage, &#39;Fields&#39;)
    for field in self.fields:
        fields.append(field.xml())
    return xmessage if not indent else _indent_xml(xmessage)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageDefinitions"><code class="flex name class">
<span>class <span class="ident">MessageDefinitions</span></span>
<span>(</span><span>services:Â <a title="idpmodem.codecs.common_mdf.Services" href="#idpmodem.codecs.common_mdf.Services">Services</a>Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A set of Message Definitions grouped into Services.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>services</code></strong></dt>
<dd>The list of Services with Messages defined.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageDefinitions:
    &#34;&#34;&#34;A set of Message Definitions grouped into Services.

    Attributes:
        services: The list of Services with Messages defined.
    
    &#34;&#34;&#34;
    def __init__(self, services: Services = None):
        if services is not None:
            if not isinstance(services, Services):
                raise ValueError(&#39;Invalid Services&#39;)
        self.services = services or Services()
    
    def xml(self, indent: bool = False) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the complete message definitions.
        
        Args:
            indent: If `True` each layer of the XML will indent 2 spaces.

        &#34;&#34;&#34;
        xmsgdef = ET.Element(&#39;MessageDefinition&#39;,
                             attrib={&#39;xmlns:xsd&#39;: XML_NAMESPACE[&#39;xsd&#39;]})
        services = ET.SubElement(xmsgdef, &#39;Services&#39;)
        for service in self.services:
            # assert isinstance(service, ServiceCodec)
            services.append(service.xml())
        return xmsgdef if not indent else _indent_xml(xmsgdef)
    
    def mdf_export(self, filename: str, pretty: bool = False):
        &#34;&#34;&#34;Creates an XML file at the target location.
        
        Args:
            filename: The full path/filename to save to. `.idpmsg` is
                recommended as a file extension.
            pretty: If `True` will indent each layer of the XML by 2 spaces.

        &#34;&#34;&#34;
        tree = ET.ElementTree(self.xml())
        root = tree.getroot()
        if pretty:
            from xml.dom.minidom import parseString
            xmlstr = parseString(ET.tostring(root)).toprettyxml(indent=&#34;  &#34;)
            with open(filename, &#39;w&#39;) as f:
                f.write(xmlstr)
        else:
            with open(filename, &#39;wb&#39;) as f:
                tree.write(f, encoding=&#39;utf-8&#39;, xml_declaration=True)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.MessageDefinitions.mdf_export"><code class="name flex">
<span>def <span class="ident">mdf_export</span></span>(<span>self, filename:Â str, pretty:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an XML file at the target location.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>The full path/filename to save to. <code>.idpmsg</code> is
recommended as a file extension.</dd>
<dt><strong><code>pretty</code></strong></dt>
<dd>If <code>True</code> will indent each layer of the XML by 2 spaces.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mdf_export(self, filename: str, pretty: bool = False):
    &#34;&#34;&#34;Creates an XML file at the target location.
    
    Args:
        filename: The full path/filename to save to. `.idpmsg` is
            recommended as a file extension.
        pretty: If `True` will indent each layer of the XML by 2 spaces.

    &#34;&#34;&#34;
    tree = ET.ElementTree(self.xml())
    root = tree.getroot()
    if pretty:
        from xml.dom.minidom import parseString
        xmlstr = parseString(ET.tostring(root)).toprettyxml(indent=&#34;  &#34;)
        with open(filename, &#39;w&#39;) as f:
            f.write(xmlstr)
    else:
        with open(filename, &#39;wb&#39;) as f:
            tree.write(f, encoding=&#39;utf-8&#39;, xml_declaration=True)</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.MessageDefinitions.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self, indent:Â boolÂ =Â False) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the XML structure of the complete message definitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong></dt>
<dd>If <code>True</code> each layer of the XML will indent 2 spaces.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self, indent: bool = False) -&gt; ET.Element:
    &#34;&#34;&#34;Gets the XML structure of the complete message definitions.
    
    Args:
        indent: If `True` each layer of the XML will indent 2 spaces.

    &#34;&#34;&#34;
    xmsgdef = ET.Element(&#39;MessageDefinition&#39;,
                         attrib={&#39;xmlns:xsd&#39;: XML_NAMESPACE[&#39;xsd&#39;]})
    services = ET.SubElement(xmsgdef, &#39;Services&#39;)
    for service in self.services:
        # assert isinstance(service, ServiceCodec)
        services.append(service.xml())
    return xmsgdef if not indent else _indent_xml(xmsgdef)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.Messages"><code class="flex name class">
<span>class <span class="ident">Messages</span></span>
<span>(</span><span>sin:Â int, is_forward:Â bool)</span>
</code></dt>
<dd>
<div class="desc"><p>The list of Messages (Forward or Return) within a Service.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Messages(CodecList):
    &#34;&#34;&#34;The list of Messages (Forward or Return) within a Service.&#34;&#34;&#34;
    def __init__(self, sin: int, is_forward: bool):
        super().__init__(codec_cls=MessageCodec)
        self.sin = sin
        self.is_forward = is_forward
    
    def add(self, message: MessageCodec) -&gt; None:
        &#34;&#34;&#34;Add a message to the list if it matches the parent SIN.

        Overrides the base class add method.

        Args:
            message (object): A valid Message
        
        Raises:
            ValueError if there is a duplicate or invalid name,
                invalid value_range or unsupported data_type

        &#34;&#34;&#34;
        if not isinstance(message, MessageCodec):
            raise ValueError(&#39;Invalid message definition&#39;)
        if message.sin != self.sin:
            raise ValueError(f&#39;Message SIN {message.sin} does not match&#39;
                             f&#39; service {self.sin}&#39;)
        for m in self:
            assert isinstance(m, MessageCodec)
            if m.name == message.name:
                raise ValueError(f&#39;Duplicate message name {message.name} found&#39;)
            if m.min == message.min:
                raise ValueError(f&#39;Duplicate message MIN {message.min} found&#39;)
        self.append(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.CodecList" href="#idpmodem.codecs.common_mdf.CodecList">CodecList</a></li>
<li>builtins.list</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.Messages.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, message:Â <a title="idpmodem.codecs.common_mdf.MessageCodec" href="#idpmodem.codecs.common_mdf.MessageCodec">MessageCodec</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a message to the list if it matches the parent SIN.</p>
<p>Overrides the base class add method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>object</code></dt>
<dd>A valid Message</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError if there is a duplicate or invalid name,
invalid value_range or unsupported data_type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, message: MessageCodec) -&gt; None:
    &#34;&#34;&#34;Add a message to the list if it matches the parent SIN.

    Overrides the base class add method.

    Args:
        message (object): A valid Message
    
    Raises:
        ValueError if there is a duplicate or invalid name,
            invalid value_range or unsupported data_type

    &#34;&#34;&#34;
    if not isinstance(message, MessageCodec):
        raise ValueError(&#39;Invalid message definition&#39;)
    if message.sin != self.sin:
        raise ValueError(f&#39;Message SIN {message.sin} does not match&#39;
                         f&#39; service {self.sin}&#39;)
    for m in self:
        assert isinstance(m, MessageCodec)
        if m.name == message.name:
            raise ValueError(f&#39;Duplicate message name {message.name} found&#39;)
        if m.min == message.min:
            raise ValueError(f&#39;Duplicate message MIN {message.min} found&#39;)
    self.append(message)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="idpmodem.codecs.common_mdf.CodecList" href="#idpmodem.codecs.common_mdf.CodecList">CodecList</a></b></code>:
<ul class="hlist">
<li><code><a title="idpmodem.codecs.common_mdf.CodecList.delete" href="#idpmodem.codecs.common_mdf.CodecList.delete">delete</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="idpmodem.codecs.common_mdf.ServiceCodec"><code class="flex name class">
<span>class <span class="ident">ServiceCodec</span></span>
<span>(</span><span>name:Â str, sin:Â int, description:Â strÂ =Â None, messages_forward:Â <a title="idpmodem.codecs.common_mdf.Messages" href="#idpmodem.codecs.common_mdf.Messages">Messages</a>Â =Â None, messages_return:Â <a title="idpmodem.codecs.common_mdf.Messages" href="#idpmodem.codecs.common_mdf.Messages">Messages</a>Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A data structure holding a set of related Forward and Return Messages.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The service name</dd>
<dt><strong><code>sin</code></strong> :&ensp;<code>int</code></dt>
<dd>Service Identification Number or codec service id (16..255)</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A description of the service (unsupported)</dd>
<dt><strong><code>messages_forward</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of mobile-terminated Message definitions</dd>
<dt><strong><code>messages_return</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of mobile-originated Message definitions</dd>
</dl>
<p>Instantiates a Service made up of Messages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The service name should be unique within a MessageDefinitions</dd>
<dt><strong><code>sin</code></strong></dt>
<dd>The Service Identification Number (16..255)</dd>
<dt><strong><code>description</code></strong></dt>
<dd>(Optional)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServiceCodec(BaseCodec):
    &#34;&#34;&#34;A data structure holding a set of related Forward and Return Messages.
    
    Attributes:
        name (str): The service name
        sin (int): Service Identification Number or codec service id (16..255)
        description (str): A description of the service (unsupported)
        messages_forward (list): A list of mobile-terminated Message definitions
        messages_return (list): A list of mobile-originated Message definitions

    &#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 sin: int,
                 description: str = None,
                 messages_forward: Messages = None,
                 messages_return: Messages = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a Service made up of Messages.
        
        Args:
            name: The service name should be unique within a MessageDefinitions
            sin: The Service Identification Number (16..255)
            description: (Optional)
        &#34;&#34;&#34;
        if not isinstance(name, str) or name == &#39;&#39;:
            raise ValueError(f&#39;Invalid service name {name}&#39;)
        if sin not in range(16, 256):
            raise ValueError(&#39;Invalid SIN must be 16..255&#39;)
        if description is not None:
            warn(&#39;Service Description not currently supported&#39;)
        super().__init__(name, description)
        self._sin = sin
        self._messages_forward = (messages_forward or
                                  Messages(self.sin, is_forward=True))
        self._messages_return = (messages_return or
                                 Messages(self.sin, is_forward=False))
    
    @property
    def sin(self) -&gt; int:
        return self._sin
    
    @property
    def messages_forward(self) -&gt; Messages:
        return self._messages_forward
    
    @messages_forward.setter
    def messages_forward(self, messages: Messages):
        if not isinstance(messages, Messages):
            raise ValueError(&#39;Invalid messages list&#39;)
        for message in messages:
            assert isinstance(message, MessageCodec)
            if not message.is_forward:
                raise ValueError(f&#39;Message {message.name} is_forward is False&#39;)
        self._messages_forward = messages

    @property
    def messages_return(self) -&gt; Messages:
        return self._messages_return
    
    @messages_return.setter
    def messages_return(self, messages: Messages):
        if not isinstance(messages, Messages):
            raise ValueError(&#39;Invalid messages list&#39;)
        for message in messages:
            assert isinstance(message, MessageCodec)
            if message.is_forward:
                raise ValueError(f&#39;Message {message.name} is_forward is True&#39;)
        self._messages_return = messages
        
    def xml(self, indent: bool = False) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the Service.&#34;&#34;&#34;
        if len(self.messages_forward) == 0 and len(self.messages_return) == 0:
            raise ValueError(f&#39;No messages defined for service {self.sin}&#39;)
        xservice = ET.Element(&#39;Service&#39;)
        name = ET.SubElement(xservice, &#39;Name&#39;)
        name.text = str(self.name)
        sin = ET.SubElement(xservice, &#39;SIN&#39;)
        sin.text = str(self.sin)
        if self.description:
            desc = ET.SubElement(xservice, &#39;Description&#39;)
            desc.text = str(self.description)
        if len(self.messages_forward) &gt; 0:
            forward_messages = ET.SubElement(xservice, &#39;ForwardMessages&#39;)
            for m in self.messages_forward:
                forward_messages.append(m.xml())
        if len(self.messages_return) &gt; 0:
            return_messages = ET.SubElement(xservice, &#39;ReturnMessages&#39;)
            for m in self.messages_return:
                return_messages.append(m.xml())
        return xservice if not indent else _indent_xml(xservice)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.ServiceCodec.messages_forward"><code class="name">var <span class="ident">messages_forward</span> :Â <a title="idpmodem.codecs.common_mdf.Messages" href="#idpmodem.codecs.common_mdf.Messages">Messages</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def messages_forward(self) -&gt; Messages:
    return self._messages_forward</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ServiceCodec.messages_return"><code class="name">var <span class="ident">messages_return</span> :Â <a title="idpmodem.codecs.common_mdf.Messages" href="#idpmodem.codecs.common_mdf.Messages">Messages</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def messages_return(self) -&gt; Messages:
    return self._messages_return</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.ServiceCodec.sin"><code class="name">var <span class="ident">sin</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sin(self) -&gt; int:
    return self._sin</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.ServiceCodec.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self, indent:Â boolÂ =Â False) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the XML structure of the Service.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self, indent: bool = False) -&gt; ET.Element:
    &#34;&#34;&#34;Gets the XML structure of the Service.&#34;&#34;&#34;
    if len(self.messages_forward) == 0 and len(self.messages_return) == 0:
        raise ValueError(f&#39;No messages defined for service {self.sin}&#39;)
    xservice = ET.Element(&#39;Service&#39;)
    name = ET.SubElement(xservice, &#39;Name&#39;)
    name.text = str(self.name)
    sin = ET.SubElement(xservice, &#39;SIN&#39;)
    sin.text = str(self.sin)
    if self.description:
        desc = ET.SubElement(xservice, &#39;Description&#39;)
        desc.text = str(self.description)
    if len(self.messages_forward) &gt; 0:
        forward_messages = ET.SubElement(xservice, &#39;ForwardMessages&#39;)
        for m in self.messages_forward:
            forward_messages.append(m.xml())
    if len(self.messages_return) &gt; 0:
        return_messages = ET.SubElement(xservice, &#39;ReturnMessages&#39;)
        for m in self.messages_return:
            return_messages.append(m.xml())
    return xservice if not indent else _indent_xml(xservice)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.Services"><code class="flex name class">
<span>class <span class="ident">Services</span></span>
<span>(</span><span>services:Â list[<a title="idpmodem.codecs.common_mdf.ServiceCodec" href="#idpmodem.codecs.common_mdf.ServiceCodec">ServiceCodec</a>]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>The list of Service(s) within a MessageDefinitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Services(CodecList):
    &#34;&#34;&#34;The list of Service(s) within a MessageDefinitions.&#34;&#34;&#34;
    def __init__(self, services: &#39;list[ServiceCodec]&#39; = None):
        super().__init__(codec_cls=ServiceCodec)
        if services is not None:
            for service in services:
                if not isinstance(service, ServiceCodec):
                    raise ValueError(f&#39;Invalid Service {service}&#39;)
                self.add(service)
    
    def add(self, service: ServiceCodec) -&gt; None:
        &#34;&#34;&#34;Adds a Service to the list of Services.&#34;&#34;&#34;
        if not isinstance(service, ServiceCodec):
            raise ValueError(f&#39;{service} is not a valid Service&#39;)
        if service.name in self:
            raise ValueError(f&#39;Duplicate Service {service.name}&#39;)
        for existing_service in self:
            if existing_service.sin == service.sin:
                raise ValueError(f&#39;Duplicate SIN {service.sin}&#39;)
        self.append(service)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.CodecList" href="#idpmodem.codecs.common_mdf.CodecList">CodecList</a></li>
<li>builtins.list</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.Services.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, service:Â <a title="idpmodem.codecs.common_mdf.ServiceCodec" href="#idpmodem.codecs.common_mdf.ServiceCodec">ServiceCodec</a>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a Service to the list of Services.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, service: ServiceCodec) -&gt; None:
    &#34;&#34;&#34;Adds a Service to the list of Services.&#34;&#34;&#34;
    if not isinstance(service, ServiceCodec):
        raise ValueError(f&#39;{service} is not a valid Service&#39;)
    if service.name in self:
        raise ValueError(f&#39;Duplicate Service {service.name}&#39;)
    for existing_service in self:
        if existing_service.sin == service.sin:
            raise ValueError(f&#39;Duplicate SIN {service.sin}&#39;)
    self.append(service)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="idpmodem.codecs.common_mdf.CodecList" href="#idpmodem.codecs.common_mdf.CodecList">CodecList</a></b></code>:
<ul class="hlist">
<li><code><a title="idpmodem.codecs.common_mdf.CodecList.delete" href="#idpmodem.codecs.common_mdf.CodecList.delete">delete</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="idpmodem.codecs.common_mdf.SignedIntField"><code class="flex name class">
<span>class <span class="ident">SignedIntField</span></span>
<span>(</span><span>name:Â str, size:Â int, data_type:Â strÂ =Â 'int_16', description:Â strÂ =Â None, optional:Â boolÂ =Â False, default:Â intÂ =Â None, value:Â intÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A signed integer value using a defined number of bits over-the-air.</p>
<p>Instantiates a SignedIntField.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The field name must be unique within a Message.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The number of <em>bits</em> used to encode the integer over-the-air
(maximum 32).</dd>
<dt><strong><code>data_type</code></strong></dt>
<dd>The integer type represented (for decoding).</dd>
<dt><strong><code>description</code></strong></dt>
<dd>An optional description/purpose for the string.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>Indicates if the string is optional in the Message.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>A default value for the string.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Optional value to set during initialization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignedIntField(FieldCodec):
    &#34;&#34;&#34;A signed integer value using a defined number of bits over-the-air.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 data_type: str = &#39;int_16&#39;,
                 description: str = None,
                 optional: bool = False,
                 default: int = None,
                 value: int = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a SignedIntField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The number of *bits* used to encode the integer over-the-air
                (maximum 32).
            data_type: The integer type represented (for decoding).
            description: An optional description/purpose for the string.
            optional: Indicates if the string is optional in the Message.
            default: A default value for the string.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        if data_type not in [&#39;int_8&#39;, &#39;int_16&#39;, &#39;int_32&#39;]:
            raise ValueError(f&#39;Invalid unsignedint type {data_type}&#39;)
        super().__init__(name=name,
                         data_type=data_type,
                         description=description,
                         optional=optional)
        self._size = size
        self._default = default
        self._value = value if value is not None else self._default
    
    @property
    def size(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self._size

    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bits&#39;)
        self._size = value

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, v: int):
        clip = False
        if v is not None:
            if not isinstance(v, int):
                raise ValueError(&#39;Unsignedint must be non-negative integer&#39;)
            if v &gt; (2**self.size / 2) - 1:
                self._value = int(2**self.size / 2) - 1
                warn(f&#39;Clipping signedint at max value {self._value}&#39;)
                clip = True
            if v &lt; -(2**self.size / 2):
                self._value = -1 * int(2**self.size / 2)
                warn(f&#39;Clipping signedint at min value {self._value}&#39;)
                clip = True
        if not clip:
            self._value = v
    
    @property
    def default(self):
        &#34;&#34;&#34;The default value.&#34;&#34;&#34;
        return self._default
    
    @default.setter
    def default(self, v: int):
        if v is not None:
            if not isinstance(v, int):
                raise ValueError(f&#39;Invalid signed integer {v}&#39;)
            if v &gt; (2**self.size / 2) - 1 or v &lt; -(2**self.size / 2):
                raise ValueError(f&#39;Invalid default {v}&#39;)
        self._default = v
    
    @property
    def bits(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self.size
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, SignedIntField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None:
            raise ValueError(f&#39;No value defined in UnsignedIntField {self.name}&#39;)
        _format = f&#39;0{self.bits}b&#39;
        if self.value &lt; 0:
            invertedbin = format(self.value * -1, _format)
            twocomplementbin = &#39;&#39;
            i = 0
            while len(twocomplementbin) &lt; len(invertedbin):
                twocomplementbin += &#39;1&#39; if invertedbin[i] == &#39;0&#39; else &#39;0&#39;
                i += 1
            binstr = format(int(twocomplementbin, 2) + 1, _format)
        else:
            binstr = format(self.value, _format)
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        value = int(binary_str[:self.bits], 2)
        if (value &amp; (1 &lt;&lt; (self.bits - 1))) != 0:   #:sign bit set e.g. 8bit: 128-255
            value = value - (1 &lt;&lt; self.bits)        #:compute negative value
        self.value = value
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the SignedIntField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.SignedIntField.bits"><code class="name">var <span class="ident">bits</span></code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self):
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    return self.size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.SignedIntField.default"><code class="name">var <span class="ident">default</span></code></dt>
<dd>
<div class="desc"><p>The default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self):
    &#34;&#34;&#34;The default value.&#34;&#34;&#34;
    return self._default</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.SignedIntField.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.SignedIntField.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.SignedIntField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, binary_str:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Populates the field value from binary and returns the next offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The binary string to decode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bit offset after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, binary_str: str) -&gt; int:
    &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
    
    Args:
        binary_str (str): The binary string to decode
    
    Returns:
        The bit offset after parsing
    &#34;&#34;&#34;
    value = int(binary_str[:self.bits], 2)
    if (value &amp; (1 &lt;&lt; (self.bits - 1))) != 0:   #:sign bit set e.g. 8bit: 128-255
        value = value - (1 &lt;&lt; self.bits)        #:compute negative value
    self.value = value
    return self.bits</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.SignedIntField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the binary string of the field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; str:
    &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
    if self.value is None:
        raise ValueError(f&#39;No value defined in UnsignedIntField {self.name}&#39;)
    _format = f&#39;0{self.bits}b&#39;
    if self.value &lt; 0:
        invertedbin = format(self.value * -1, _format)
        twocomplementbin = &#39;&#39;
        i = 0
        while len(twocomplementbin) &lt; len(invertedbin):
            twocomplementbin += &#39;1&#39; if invertedbin[i] == &#39;0&#39; else &#39;0&#39;
            i += 1
        binstr = format(int(twocomplementbin, 2) + 1, _format)
    else:
        binstr = format(self.value, _format)
    return binstr</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.SignedIntField.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the XML structure of the SignedIntField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self) -&gt; ET.Element:
    &#34;&#34;&#34;Gets the XML structure of the SignedIntField.&#34;&#34;&#34;
    xmlfield = self._base_xml()
    size = ET.SubElement(xmlfield, &#39;Size&#39;)
    size.text = str(self.size)
    if self.default:
        default = ET.SubElement(xmlfield, &#39;Default&#39;)
        default.text = str(self.default)
    return xmlfield</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.StringField"><code class="flex name class">
<span>class <span class="ident">StringField</span></span>
<span>(</span><span>name:Â str, size:Â int, description:Â strÂ =Â None, optional:Â boolÂ =Â False, fixed:Â boolÂ =Â False, default:Â strÂ =Â None, value:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>A character string sent over-the-air.</p>
<p>Instantiates a StringField.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The field name must be unique within a Message.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The maximum number of characters in the string.</dd>
<dt><strong><code>description</code></strong></dt>
<dd>An optional description/purpose for the string.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>Indicates if the string is optional in the Message.</dd>
<dt><strong><code>fixed</code></strong></dt>
<dd>Indicates if the string is always fixed length <code>size</code>.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>A default value for the string.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Optional value to set during initialization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringField(FieldCodec):
    &#34;&#34;&#34;A character string sent over-the-air.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 description: str = None,
                 optional: bool = False,
                 fixed: bool = False,
                 default: str = None,
                 value: str = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a StringField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The maximum number of characters in the string.
            description: An optional description/purpose for the string.
            optional: Indicates if the string is optional in the Message.
            fixed: Indicates if the string is always fixed length `size`.
            default: A default value for the string.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        super().__init__(name=name,
                         data_type=&#39;string&#39;,
                         description=description,
                         optional=optional)
        self._size = size
        self._fixed = fixed
        self._default = default
        self._value = value if value is not None else self._default
    
    def _validate_string(self, s: str) -&gt; str:
        if s is not None:
            if not isinstance(s, str):
                raise ValueError(f&#39;Invalid string {s}&#39;)
            if len(s) &gt; self.size:
                warn(f&#39;Clipping string at max {self.size} characters&#39;)
                return s[:self.size]
        return s
                
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;The maximum size of the string in characters.&#34;&#34;&#34;
        return self._size
    
    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 characters&#39;)
        self._size = value
    
    @property
    def default(self) -&gt; str:
        &#34;&#34;&#34;The default value.&#34;&#34;&#34;
        return self._default
    
    @default.setter
    def default(self, v: str):
        self._default = self._validate_string(v)

    @property
    def value(self) -&gt; str:
        return self._value
    
    @value.setter
    def value(self, v: str):
        self._value = self._validate_string(v)

    @property
    def fixed(self) -&gt; bool:
        &#34;&#34;&#34;Indicates whether the string length is fixed (padded/truncated).&#34;&#34;&#34;
        return self._fixed

    @property
    def bits(self) -&gt; int:
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        if self.fixed or self.value is None:
            return self.size * 8
        return len(self.value) * 8
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, StringField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None and not self.optional:
            raise ValueError(f&#39;No value defined for StringField {self.name}&#39;)
        binstr = &#39;&#39;.join(format(ord(c), &#39;08b&#39;) for c in self.value)
        if self.fixed:
            binstr += &#39;&#39;.join(&#39;0&#39; for bit in range(len(binstr), self.bits))
        else:
            binstr = _encode_field_length(len(self.value)) + binstr
        return binstr

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        if self.fixed:
            length = self.size
            bit_index = 0
        else:
            (length, bit_index) = _decode_field_length(binary_str)
        n = int(binary_str[bit_index:bit_index + length * 8], 2)
        char_bytes = n.to_bytes((n.bit_length() + 7) // 8, &#39;big&#39;)
        for i, byte in enumerate(char_bytes):
            if byte == 0:
                warn(&#39;Truncating after 0 byte in string&#39;)
                char_bytes = char_bytes[:i]
                break
        self.value = char_bytes.decode(&#39;utf-8&#39;, &#39;surrogatepass&#39;) or &#39;\0&#39;
        return bit_index + length * 8

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the StringField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.fixed:
            fixed = ET.SubElement(xmlfield, &#39;Fixed&#39;)
            fixed.text = &#39;true&#39;
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.StringField.bits"><code class="name">var <span class="ident">bits</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self) -&gt; int:
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    if self.fixed or self.value is None:
        return self.size * 8
    return len(self.value) * 8</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.StringField.default"><code class="name">var <span class="ident">default</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self) -&gt; str:
    &#34;&#34;&#34;The default value.&#34;&#34;&#34;
    return self._default</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.StringField.fixed"><code class="name">var <span class="ident">fixed</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Indicates whether the string length is fixed (padded/truncated).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fixed(self) -&gt; bool:
    &#34;&#34;&#34;Indicates whether the string length is fixed (padded/truncated).&#34;&#34;&#34;
    return self._fixed</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.StringField.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The maximum size of the string in characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;The maximum size of the string in characters.&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.StringField.value"><code class="name">var <span class="ident">value</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; str:
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.StringField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, binary_str:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Populates the field value from binary and returns the next offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The binary string to decode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bit offset after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, binary_str: str) -&gt; int:
    &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
    
    Args:
        binary_str (str): The binary string to decode
    
    Returns:
        The bit offset after parsing
    &#34;&#34;&#34;
    if self.fixed:
        length = self.size
        bit_index = 0
    else:
        (length, bit_index) = _decode_field_length(binary_str)
    n = int(binary_str[bit_index:bit_index + length * 8], 2)
    char_bytes = n.to_bytes((n.bit_length() + 7) // 8, &#39;big&#39;)
    for i, byte in enumerate(char_bytes):
        if byte == 0:
            warn(&#39;Truncating after 0 byte in string&#39;)
            char_bytes = char_bytes[:i]
            break
    self.value = char_bytes.decode(&#39;utf-8&#39;, &#39;surrogatepass&#39;) or &#39;\0&#39;
    return bit_index + length * 8</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.StringField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the binary string of the field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; str:
    &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
    if self.value is None and not self.optional:
        raise ValueError(f&#39;No value defined for StringField {self.name}&#39;)
    binstr = &#39;&#39;.join(format(ord(c), &#39;08b&#39;) for c in self.value)
    if self.fixed:
        binstr += &#39;&#39;.join(&#39;0&#39; for bit in range(len(binstr), self.bits))
    else:
        binstr = _encode_field_length(len(self.value)) + binstr
    return binstr</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.StringField.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the XML structure of the StringField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self) -&gt; ET.Element:
    &#34;&#34;&#34;Gets the XML structure of the StringField.&#34;&#34;&#34;
    xmlfield = self._base_xml()
    size = ET.SubElement(xmlfield, &#39;Size&#39;)
    size.text = str(self.size)
    if self.fixed:
        fixed = ET.SubElement(xmlfield, &#39;Fixed&#39;)
        fixed.text = &#39;true&#39;
    if self.default:
        default = ET.SubElement(xmlfield, &#39;Default&#39;)
        default.text = str(self.default)
    return xmlfield</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField"><code class="flex name class">
<span>class <span class="ident">UnsignedIntField</span></span>
<span>(</span><span>name:Â str, size:Â int, data_type:Â strÂ =Â 'uint_16', description:Â strÂ =Â None, optional:Â boolÂ =Â False, default:Â intÂ =Â None, value:Â intÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>An unsigned integer value using a defined number of bits over-the-air.</p>
<p>Instantiates a UnsignedIntField.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The field name must be unique within a Message.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The number of <em>bits</em> used to encode the integer over-the-air
(maximum 32).</dd>
<dt><strong><code>data_type</code></strong></dt>
<dd>The integer type represented (for decoding).</dd>
<dt><strong><code>description</code></strong></dt>
<dd>An optional description/purpose for the string.</dd>
<dt><strong><code>optional</code></strong></dt>
<dd>Indicates if the string is optional in the Message.</dd>
<dt><strong><code>default</code></strong></dt>
<dd>A default value for the string.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Optional value to set during initialization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnsignedIntField(FieldCodec):
    &#34;&#34;&#34;An unsigned integer value using a defined number of bits over-the-air.&#34;&#34;&#34;
    def __init__(self,
                 name: str,
                 size: int,
                 data_type: str = &#39;uint_16&#39;,
                 description: str = None,
                 optional: bool = False,
                 default: int = None,
                 value: int = None) -&gt; None:
        &#34;&#34;&#34;Instantiates a UnsignedIntField.
        
        Args:
            name: The field name must be unique within a Message.
            size: The number of *bits* used to encode the integer over-the-air
                (maximum 32).
            data_type: The integer type represented (for decoding).
            description: An optional description/purpose for the string.
            optional: Indicates if the string is optional in the Message.
            default: A default value for the string.
            value: Optional value to set during initialization.

        &#34;&#34;&#34;
        if data_type not in [&#39;uint_8&#39;, &#39;uint_16&#39;, &#39;uint_32&#39;]:
            raise ValueError(f&#39;Invalid unsignedint type {data_type}&#39;)
        super().__init__(name=name,
                         data_type=data_type,
                         description=description,
                         optional=optional)
        self._size = size
        self._default = default
        self._value = value if value is not None else self._default
    
    @property
    def size(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self._size

    @size.setter
    def size(self, value: int):
        if not isinstance(value, int) or value &lt; 1:
            raise ValueError(&#39;Size must be integer greater than 0 bits&#39;)
        data_type_size = int(self.data_type.split(&#39;_&#39;)[1])
        if value &gt; data_type_size:
            warn(f&#39;Size {value} larger than required by {self.data_type}&#39;)
        self._size = value

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, v: int):
        clip = False
        if v is not None:
            if not isinstance(v, int) or v &lt; 0:
                raise ValueError(&#39;Unsignedint must be non-negative integer&#39;)
            if v &gt; 2**self.size - 1:
                self._value = 2**self.size - 1
                warn(f&#39;Clipping unsignedint at max value {self._value}&#39;)
                clip = True
        if not clip:
            self._value = v
    
    @property
    def default(self):
        &#34;&#34;&#34;The default value.&#34;&#34;&#34;
        return self._default
    
    @default.setter
    def default(self, v: int):
        if v is not None:
            if v &gt; 2**self.size - 1 or v &lt; 0:
                raise ValueError(F&#39;Invalid unsignedint default {v}&#39;)
        self._default = v
    
    @property
    def bits(self):
        &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
        return self.size
    
    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, UnsignedIntField):
            return NotImplemented
        return _attribute_equivalence(self, other)

    def encode(self) -&gt; str:
        &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
        if self.value is None:
            raise ValueError(f&#39;No value defined in UnsignedIntField {self.name}&#39;)
        _format = f&#39;0{self.bits}b&#39;
        return format(self.value, _format)

    def decode(self, binary_str: str) -&gt; int:
        &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
        
        Args:
            binary_str (str): The binary string to decode
        
        Returns:
            The bit offset after parsing
        &#34;&#34;&#34;
        self.value = int(binary_str[:self.bits], 2)
        return self.bits

    def xml(self) -&gt; ET.Element:
        &#34;&#34;&#34;Gets the XML structure of the UnsignedIntField.&#34;&#34;&#34;
        xmlfield = self._base_xml()
        size = ET.SubElement(xmlfield, &#39;Size&#39;)
        size.text = str(self.size)
        if self.default:
            default = ET.SubElement(xmlfield, &#39;Default&#39;)
            default.text = str(self.default)
        return xmlfield</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></li>
<li><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField.bits"><code class="name">var <span class="ident">bits</span></code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self):
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    return self.size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField.default"><code class="name">var <span class="ident">default</span></code></dt>
<dd>
<div class="desc"><p>The default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default(self):
    &#34;&#34;&#34;The default value.&#34;&#34;&#34;
    return self._default</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>The size of the field in bits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34;The size of the field in bits.&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, binary_str:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Populates the field value from binary and returns the next offset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>binary_str</code></strong> :&ensp;<code>str</code></dt>
<dd>The binary string to decode</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The bit offset after parsing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, binary_str: str) -&gt; int:
    &#34;&#34;&#34;Populates the field value from binary and returns the next offset.
    
    Args:
        binary_str (str): The binary string to decode
    
    Returns:
        The bit offset after parsing
    &#34;&#34;&#34;
    self.value = int(binary_str[:self.bits], 2)
    return self.bits</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the binary string of the field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self) -&gt; str:
    &#34;&#34;&#34;Returns the binary string of the field value.&#34;&#34;&#34;
    if self.value is None:
        raise ValueError(f&#39;No value defined in UnsignedIntField {self.name}&#39;)
    _format = f&#39;0{self.bits}b&#39;
    return format(self.value, _format)</code></pre>
</details>
</dd>
<dt id="idpmodem.codecs.common_mdf.UnsignedIntField.xml"><code class="name flex">
<span>def <span class="ident">xml</span></span>(<span>self) â€‘>Â xml.etree.ElementTree.Element</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the XML structure of the UnsignedIntField.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml(self) -&gt; ET.Element:
    &#34;&#34;&#34;Gets the XML structure of the UnsignedIntField.&#34;&#34;&#34;
    xmlfield = self._base_xml()
    size = ET.SubElement(xmlfield, &#39;Size&#39;)
    size.text = str(self.size)
    if self.default:
        default = ET.SubElement(xmlfield, &#39;Default&#39;)
        default.text = str(self.default)
    return xmlfield</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="idpmodem.codecs" href="index.html">idpmodem.codecs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.optimal_bits" href="#idpmodem.codecs.common_mdf.optimal_bits">optimal_bits</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.ArrayField" href="#idpmodem.codecs.common_mdf.ArrayField">ArrayField</a></code></h4>
<ul class="two-column">
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.bits" href="#idpmodem.codecs.common_mdf.ArrayField.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.decode" href="#idpmodem.codecs.common_mdf.ArrayField.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.elements" href="#idpmodem.codecs.common_mdf.ArrayField.elements">elements</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.encode" href="#idpmodem.codecs.common_mdf.ArrayField.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.fields" href="#idpmodem.codecs.common_mdf.ArrayField.fields">fields</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.fixed" href="#idpmodem.codecs.common_mdf.ArrayField.fixed">fixed</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.new_element" href="#idpmodem.codecs.common_mdf.ArrayField.new_element">new_element</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.size" href="#idpmodem.codecs.common_mdf.ArrayField.size">size</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ArrayField.xml" href="#idpmodem.codecs.common_mdf.ArrayField.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.BaseCodec" href="#idpmodem.codecs.common_mdf.BaseCodec">BaseCodec</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.BaseCodec.description" href="#idpmodem.codecs.common_mdf.BaseCodec.description">description</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.BaseCodec.name" href="#idpmodem.codecs.common_mdf.BaseCodec.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.BooleanField" href="#idpmodem.codecs.common_mdf.BooleanField">BooleanField</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.BooleanField.decode" href="#idpmodem.codecs.common_mdf.BooleanField.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.BooleanField.default" href="#idpmodem.codecs.common_mdf.BooleanField.default">default</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.BooleanField.encode" href="#idpmodem.codecs.common_mdf.BooleanField.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.BooleanField.value" href="#idpmodem.codecs.common_mdf.BooleanField.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.CodecList" href="#idpmodem.codecs.common_mdf.CodecList">CodecList</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.CodecList.add" href="#idpmodem.codecs.common_mdf.CodecList.add">add</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.CodecList.delete" href="#idpmodem.codecs.common_mdf.CodecList.delete">delete</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.DataField" href="#idpmodem.codecs.common_mdf.DataField">DataField</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.DataField.SUPPORTED_DATA_TYPES" href="#idpmodem.codecs.common_mdf.DataField.SUPPORTED_DATA_TYPES">SUPPORTED_DATA_TYPES</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.bits" href="#idpmodem.codecs.common_mdf.DataField.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.converted_value" href="#idpmodem.codecs.common_mdf.DataField.converted_value">converted_value</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.decode" href="#idpmodem.codecs.common_mdf.DataField.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.default" href="#idpmodem.codecs.common_mdf.DataField.default">default</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.encode" href="#idpmodem.codecs.common_mdf.DataField.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.fixed" href="#idpmodem.codecs.common_mdf.DataField.fixed">fixed</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.precision" href="#idpmodem.codecs.common_mdf.DataField.precision">precision</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.size" href="#idpmodem.codecs.common_mdf.DataField.size">size</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.value" href="#idpmodem.codecs.common_mdf.DataField.value">value</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.DataField.xml" href="#idpmodem.codecs.common_mdf.DataField.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.EnumField" href="#idpmodem.codecs.common_mdf.EnumField">EnumField</a></code></h4>
<ul class="two-column">
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.bits" href="#idpmodem.codecs.common_mdf.EnumField.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.decode" href="#idpmodem.codecs.common_mdf.EnumField.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.default" href="#idpmodem.codecs.common_mdf.EnumField.default">default</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.encode" href="#idpmodem.codecs.common_mdf.EnumField.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.items" href="#idpmodem.codecs.common_mdf.EnumField.items">items</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.size" href="#idpmodem.codecs.common_mdf.EnumField.size">size</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.value" href="#idpmodem.codecs.common_mdf.EnumField.value">value</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.EnumField.xml" href="#idpmodem.codecs.common_mdf.EnumField.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.FieldCodec" href="#idpmodem.codecs.common_mdf.FieldCodec">FieldCodec</a></code></h4>
<ul class="two-column">
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.bits" href="#idpmodem.codecs.common_mdf.FieldCodec.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.data_type" href="#idpmodem.codecs.common_mdf.FieldCodec.data_type">data_type</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.decode" href="#idpmodem.codecs.common_mdf.FieldCodec.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.encode" href="#idpmodem.codecs.common_mdf.FieldCodec.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.optional" href="#idpmodem.codecs.common_mdf.FieldCodec.optional">optional</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.FieldCodec.xml" href="#idpmodem.codecs.common_mdf.FieldCodec.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.Fields" href="#idpmodem.codecs.common_mdf.Fields">Fields</a></code></h4>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.MessageCodec" href="#idpmodem.codecs.common_mdf.MessageCodec">MessageCodec</a></code></h4>
<ul class="two-column">
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.decode" href="#idpmodem.codecs.common_mdf.MessageCodec.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.encode" href="#idpmodem.codecs.common_mdf.MessageCodec.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.fields" href="#idpmodem.codecs.common_mdf.MessageCodec.fields">fields</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.is_forward" href="#idpmodem.codecs.common_mdf.MessageCodec.is_forward">is_forward</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.min" href="#idpmodem.codecs.common_mdf.MessageCodec.min">min</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.ota_size" href="#idpmodem.codecs.common_mdf.MessageCodec.ota_size">ota_size</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.sin" href="#idpmodem.codecs.common_mdf.MessageCodec.sin">sin</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageCodec.xml" href="#idpmodem.codecs.common_mdf.MessageCodec.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.MessageDefinitions" href="#idpmodem.codecs.common_mdf.MessageDefinitions">MessageDefinitions</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.MessageDefinitions.mdf_export" href="#idpmodem.codecs.common_mdf.MessageDefinitions.mdf_export">mdf_export</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.MessageDefinitions.xml" href="#idpmodem.codecs.common_mdf.MessageDefinitions.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.Messages" href="#idpmodem.codecs.common_mdf.Messages">Messages</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.Messages.add" href="#idpmodem.codecs.common_mdf.Messages.add">add</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.ServiceCodec" href="#idpmodem.codecs.common_mdf.ServiceCodec">ServiceCodec</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.ServiceCodec.messages_forward" href="#idpmodem.codecs.common_mdf.ServiceCodec.messages_forward">messages_forward</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ServiceCodec.messages_return" href="#idpmodem.codecs.common_mdf.ServiceCodec.messages_return">messages_return</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ServiceCodec.sin" href="#idpmodem.codecs.common_mdf.ServiceCodec.sin">sin</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.ServiceCodec.xml" href="#idpmodem.codecs.common_mdf.ServiceCodec.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.Services" href="#idpmodem.codecs.common_mdf.Services">Services</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.codecs.common_mdf.Services.add" href="#idpmodem.codecs.common_mdf.Services.add">add</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.SignedIntField" href="#idpmodem.codecs.common_mdf.SignedIntField">SignedIntField</a></code></h4>
<ul class="two-column">
<li><code><a title="idpmodem.codecs.common_mdf.SignedIntField.bits" href="#idpmodem.codecs.common_mdf.SignedIntField.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.SignedIntField.decode" href="#idpmodem.codecs.common_mdf.SignedIntField.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.SignedIntField.default" href="#idpmodem.codecs.common_mdf.SignedIntField.default">default</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.SignedIntField.encode" href="#idpmodem.codecs.common_mdf.SignedIntField.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.SignedIntField.size" href="#idpmodem.codecs.common_mdf.SignedIntField.size">size</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.SignedIntField.value" href="#idpmodem.codecs.common_mdf.SignedIntField.value">value</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.SignedIntField.xml" href="#idpmodem.codecs.common_mdf.SignedIntField.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.StringField" href="#idpmodem.codecs.common_mdf.StringField">StringField</a></code></h4>
<ul class="two-column">
<li><code><a title="idpmodem.codecs.common_mdf.StringField.bits" href="#idpmodem.codecs.common_mdf.StringField.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.StringField.decode" href="#idpmodem.codecs.common_mdf.StringField.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.StringField.default" href="#idpmodem.codecs.common_mdf.StringField.default">default</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.StringField.encode" href="#idpmodem.codecs.common_mdf.StringField.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.StringField.fixed" href="#idpmodem.codecs.common_mdf.StringField.fixed">fixed</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.StringField.size" href="#idpmodem.codecs.common_mdf.StringField.size">size</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.StringField.value" href="#idpmodem.codecs.common_mdf.StringField.value">value</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.StringField.xml" href="#idpmodem.codecs.common_mdf.StringField.xml">xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField" href="#idpmodem.codecs.common_mdf.UnsignedIntField">UnsignedIntField</a></code></h4>
<ul class="two-column">
<li><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField.bits" href="#idpmodem.codecs.common_mdf.UnsignedIntField.bits">bits</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField.decode" href="#idpmodem.codecs.common_mdf.UnsignedIntField.decode">decode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField.default" href="#idpmodem.codecs.common_mdf.UnsignedIntField.default">default</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField.encode" href="#idpmodem.codecs.common_mdf.UnsignedIntField.encode">encode</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField.size" href="#idpmodem.codecs.common_mdf.UnsignedIntField.size">size</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField.value" href="#idpmodem.codecs.common_mdf.UnsignedIntField.value">value</a></code></li>
<li><code><a title="idpmodem.codecs.common_mdf.UnsignedIntField.xml" href="#idpmodem.codecs.common_mdf.UnsignedIntField.xml">xml</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>