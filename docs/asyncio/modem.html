<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>idpmodem.asyncio.modem API documentation</title>
<meta name="description" content="IDP Modem abstraction for pyserial-asyncio â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>idpmodem.asyncio.modem</code></h1>
</header>
<section id="section-intro">
<p>IDP Modem abstraction for pyserial-asyncio.</p>
<p><strong>WARNING</strong>: This module is untested as a work in progress refactor of the
legacy atcommand_async module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;IDP Modem abstraction for pyserial-asyncio.

**WARNING**: This module is untested as a work in progress refactor of the
legacy atcommand_async module.

&#34;&#34;&#34;

import asyncio
import logging
import queue
from base64 import b64decode, b64encode
from datetime import datetime, timezone
from time import time

import serial_asyncio
from idpmodem.aterror import AtException, AtGnssTimeout
from idpmodem.constants import (AT_ERROR_CODES, EVENT_TRACES, GEOBEAMS,
                                POWER_MODES, WAKEUP_PERIODS, BeamSearchState,
                                DataFormat, EventNotification, MessagePriority,
                                MessageState, SatlliteControlState, TransmitterStatus)
from idpmodem.location import Location, location_from_nmea
from idpmodem.s_registers import SRegisters
from idpmodem.asyncio.atcommand import AtProtocol

GNSS_STALE_SECS = 1
GNSS_WAIT_SECS = 35
SAT_STATUS_HOLDOFF = 5

_log = logging.getLogger(__name__)


class ModemBusy(Exception):
    &#34;&#34;&#34;Indicates the modem is busy processing a prior command.&#34;&#34;&#34;


class AtConfiguration:
    def __init__(self) -&gt; None:
        self.crc: bool = False
        self.echo: bool = True
        self.quiet: bool = False
        self.verbose: bool = True


class IdpModem:
    &#34;&#34;&#34;A protocol factory abstracting AT commands for an IDP modem.&#34;&#34;&#34;
    
    SERIAL_KWARGS = [&#39;baudrate&#39;, &#39;timeout&#39;, &#39;write_timeout&#39;]
    BAUD_RATES = [1200, 2400, 4800, 9600, 19200]
    PROTOCOL_KWARGS = [&#39;event_callback&#39;, &#39;at_timeout&#39;]
    OTHER_KWARGS = [&#39;error_detail&#39;, &#39;debug&#39;, &#39;stale_secs&#39;, &#39;wait_secs&#39;]
    
    def __init__(self, serial_port: str, **kwargs):
        self.serial_kwargs = {
            &#39;port&#39;: serial_port,
            &#39;baudrate&#39;: int(kwargs.pop(&#39;baudrate&#39;, 9600)),
        }
        self.protocol_kwargs = {}
        self.error_detail = bool(kwargs.pop(&#39;error_detail&#39;, True))
        self.debug = bool(kwargs.pop(&#39;debug&#39;, False))
        for kwarg in kwargs:
            if kwarg in self.SERIAL_KWARGS:
                self.serial_kwargs[kwarg] = kwargs[kwarg]
            elif kwarg in self.PROTOCOL_KWARGS:
                self.protocol_kwargs[kwarg] = kwargs[kwarg]
        self.loop = asyncio.get_event_loop()
        self.coro = serial_asyncio.create_serial_connection(
            self.loop,
            protocol_factory=AtProtocol,
            **self.serial_kwargs
        )
        self.serial_port = None
        self.transport = None
        self.protocol = None
        self.commands = queue.Queue(1)
        self._at_config = AtConfiguration()
        self._mobile_id: str = None
        self._versions: dict = None
        self._power_mode: int = None
        self._wakeup_period: int = None
        self._ctrl_state: int = None
        self._snr: float = None
        self._geo_beam_id: int = None
        self._beamsearch_state: int = None
        self._loc_query: dict = {
            &#39;stale_secs&#39;: int(kwargs.pop(&#39;stale_secs&#39;, GNSS_STALE_SECS)),
            &#39;wait_secs&#39;: int(kwargs.pop(&#39;wait_secs&#39;, GNSS_WAIT_SECS)),
        }
        self._holdoffs: dict = {}   # used to ignore frequent repeat commands
        self._statistics: dict = {}
        self.s_registers = SRegisters()
        # self.tx_queue = queue.Queue()
        # self.tx_complete_callback: callable = None
        # self.rx_queue = queue.Queue()
        # self.rx_received_callback: callable = None
    
    def connect(self):
        self.transport, self.protocol = self.loop.run_until_complete(self.coro)
        self.loop.run_forever()
        _log.debug(f&#39;Transport: {self.transport}&#39;)
        # self.serial_port = Serial(**self.serial_kwargs)

    def disconnect(self):
        self.loop.close()
        self.transport = None
        self.protocol = None
    
    @property
    def connected(self) -&gt; bool:
        return self.transport is not None and self.protocol is not None

    @property
    def baudrate(self) -&gt; &#39;int|None&#39;:
        return self.transport.baudrate if self.transport else None
    
    @baudrate.setter
    def baudrate(self, value: int):
        if not self.connected:
            raise ConnectionError(&#39;Modem is not connected&#39;)
        if value not in self.BAUD_RATES:
            raise ValueError(f&#39;Baud rate must be one of {self.BAUD_RATES}&#39;)
        response = self.atcommand(f&#39;AT+IPR={value}&#39;)
        if response and response[0] != &#39;ERROR&#39;:
            self.serial_port.baudrate = value

    @property
    def crc(self) -&gt; &#39;bool|None&#39;:
        return self.protocol.crc if self.protocol is not None else None

    def atcommand(self,
                  command: str,
                  filter: &#39;list[str]&#39; = [],
                  timeout: int = 5,
                  await_previous: bool = True,
                  ) -&gt; &#39;list[str]&#39;:
        &#34;&#34;&#34;Sends an AT command to the modem and returns the response.
        
        Args:
            command: The AT command
            filter: (optional) list of sub/strings to remove from response.
            timeout: Number of seconds to wait for a reply
                (not including messages queued by other threads)
            await_previous: If True, this will block if a prior command was
                submitted by another thread
        
        Returns:
            list of filtered and stripped response(s) to the command(s)
        
        Raises:
            ModemBusy if await_previous is False and a prior command is queued.
            AtException if an error occurred that is unrecognized.

        &#34;&#34;&#34;
        if not self.connected:
            raise ConnectionError(&#39;No connection to IDP modem&#39;)
        while self.commands.full():
            if not await_previous:
                raise ModemBusy
            pass
        self.commands.put(command)
        # TODO: allow for async(?)
        res: list = self.protocol.command(command, filter, timeout, self.debug)
        if self.error_detail and res and res[0] == &#39;ERROR&#39;:
            _log.error(f&#39;Error received for command {command}&#39;)
            err_res = self.protocol.command(&#39;ATS80?&#39;)
            if not err_res or err_res[0] == &#39;ERROR&#39;:
                raise AtException(&#39;Unhandled error getting last error code&#39;)
            last_err_code = err_res[0]
            detail = &#39;UNDEFINED&#39;
            if int(last_err_code) in AT_ERROR_CODES:
                detail = AT_ERROR_CODES[int(last_err_code)]
            res.append(f&#39;{detail} ({last_err_code})&#39;)
        self.commands.get()
        self.commands.task_done()
        return res
    
    def _handle_at_exception(self, response: &#39;list[str]&#39;) -&gt; None:
        err = response[1] if self.error_detail else response[0]
        raise AtException(err)

    def config_init(self, crc: bool = False) -&gt; bool:
        &#34;&#34;&#34;Initializes modem communications with Echo, Verbose. CRC optional.&#34;&#34;&#34;
        def attempt(command: str) -&gt; bool:
            response = self.atcommand(command)
            return response[0] == &#39;OK&#39;
        # try at most twice
        command = f&#39;ATZ;E1;V1;Q0;%CRC={1 if crc else 0}&#39;
        success = attempt(command)
        if not success:
            success = attempt(command)
        if success:
            self.protocol.crc = crc
            self._at_config.crc = crc
        return success

    def config_restore_nvm(self) -&gt; bool:
        &#34;&#34;&#34;Sends ATZ to restore config from non-volatile memory.&#34;&#34;&#34;
        response = self.atcommand(&#39;ATZ&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True

    def config_restore_factory(self) -&gt; bool:
        &#34;&#34;&#34;Sends AT&amp;F to restore factory default and returns True on success.&#34;&#34;&#34;
        response = self.atcommand(&#39;AT&amp;F&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True
    
    def config_report(self) -&gt; &#39;tuple[dict, dict]&#39;:
        &#34;&#34;&#34;Sends the AT&amp;V command to retrieve S-register settings.
        
        Returns:
            A tuple with two dictionaries (empty if failed) with:
            at_config with booleans crc, echo, quiet and verbose
            reg_config with S-register tags and integer values
        
        Raises:
            AtException if an error was returned.

        &#34;&#34;&#34;
        response = self.atcommand(&#39;AT&amp;V&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        at_config = response[1]
        s_regs = response[2]
        echo, quiet, verbose, crc = at_config.split(&#39; &#39;)
        self._at_config.crc = bool(int(crc[4]))
        self._at_config.echo = bool(int(echo[1]))
        self._at_config.quiet = bool(int(quiet[1]))
        self._at_config.verbose = bool(int(verbose[1]))
        reg_config = {}
        for reg in s_regs.split(&#39; &#39;):
            name, value = reg.split(&#39;:&#39;)
            reg_config[name] = int(value)
        return (at_config, reg_config)

    def config_volatile_report(self) -&gt; &#39;dict|None&#39;:
        &#34;&#34;&#34;Returns key S-register settings.
        
        GNSS Mode (S39), GNSS fix timeout (S41), GNSS Continuous (S55),
        GNSS Jamming Status (S56), GNSS Jamming Indicator (S57), 
        Low power Wakeup Period (S51)

        Returns:
            Dictionary of S-register values, or None if failed
            
        &#34;&#34;&#34;
        register_list = [
            &#39;S39&#39;,   #: GNSS Mode
            &#39;S41&#39;,   #: GNSS Fix Timeout
            &#39;S51&#39;,   #: Wakeup Interval
            &#39;S55&#39;,   #: GNSS Continuous
            &#39;S56&#39;,   #: GNSS Jamming Status
            &#39;S57&#39;,   #: GNSS Jamming Indicator
        ]
        command = &#39;AT&#39;
        for reg in register_list:
            command += f&#39;{reg if command == &#34;AT&#34; else &#34; &#34; + reg}?&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            return None
        #: else
        response.remove(&#39;OK&#39;)
        volatile_regs = {}
        for r in range(len(response)):
            volatile_regs[register_list[r]] = int(response[r])
        return volatile_regs

    def config_nvm_save(self) -&gt; bool:
        &#34;&#34;&#34;Sends the AT&amp;W command and returns True if successful.&#34;&#34;&#34;
        response = self.atcommand(&#39;AT&amp;W&#39;)
        return response[0] == &#39;OK&#39;

    def crc_enable(self, enable: bool = True) -&gt; bool:
        &#34;&#34;&#34;Sends the AT%CRC command and returns success flag.
        
        Args:
            enable: turn on CRC if True else turn off

        Returns:
            True if the operation succeeded else False

        &#34;&#34;&#34;
        command = f&#39;AT%CRC={1 if enable else 0}&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            return False
        self.protocol.crc = enable
        self._at_config.crc = enable
        return True

    @property
    def mobile_id(self) -&gt; &#39;str|None&#39;:
        &#34;&#34;&#34;Returns the unique Mobile ID (Inmarsat serial number).&#34;&#34;&#34;
        if self._mobile_id is None:
            response = self.atcommand(&#39;AT+GSN&#39;, filter=[&#39;+GSN:&#39;])
            if response[0] != &#39;ERROR&#39;:
                self._mobile_id = response[0]
        return self._mobile_id

    @property
    def versions(self) -&gt; &#39;dict|None&#39;:
        &#34;&#34;&#34;Returns the hardware, firmware and AT versions.&#34;&#34;&#34;
        if not self._versions:
            response = self.atcommand(&#39;AT+GMR&#39;, filter=[&#39;+GMR:&#39;])
            if response[0] != &#39;ERROR&#39;:
                fw_ver, hw_ver, at_ver = response[0].split(&#39;,&#39;)
                self._versions = {
                    &#39;hardware&#39;: hw_ver,
                    &#39;firmware&#39;: fw_ver,
                    &#39;at&#39;: at_ver,
                }
        return self._versions

    @property
    def power_mode(self) -&gt; &#39;str|None&#39;:
        if self._power_mode is None:
            response = self.atcommand(&#39;ATS50?&#39;)
            if response[0] != &#39;ERROR&#39;:
                self._power_mode = int(response[0])
        if self._power_mode in POWER_MODES:
            return POWER_MODES[self._power_mode]
    
    @power_mode.setter
    def power_mode(self, value: &#39;str|int&#39;):
        if isinstance(value, str):
            if value not in POWER_MODES.values():
                raise ValueError(f&#39;Invalid power mode {value}&#39;)
            for k, v in POWER_MODES.items():
                if v == value:
                    value = k
                    break
        if value not in POWER_MODES:
            raise ValueError(f&#39;Invalid power mode {value}&#39;)
        response = self.atcommand(f&#39;ATS50={value}&#39;)
        if response[0] == &#39;OK&#39;:
            self._power_mode = value
    
    @property
    def wakeup_period(self) -&gt; &#39;str|None&#39;:
        if self._wakeup_period is None:
            response = self.atcommand(&#39;ATS51?&#39;)
            if response[0] != &#39;ERROR&#39;:
                self._wakeup_period = int(response[0])
        if self._wakeup_period in WAKEUP_PERIODS:
            return WAKEUP_PERIODS[self._wakeup_period]

    @wakeup_period.setter
    def wakeup_period(self, value: &#39;str|int&#39;):
        if isinstance(value, str):
            if value not in WAKEUP_PERIODS.values():
                raise ValueError(f&#39;Invalid wakeup period {value}&#39;)
            for k, v in WAKEUP_PERIODS.items():
                if v == value:
                    value = k
                    break
        if value not in WAKEUP_PERIODS:
            raise ValueError(f&#39;Invalid wakeup period {value}&#39;)
        response = self.atcommand(f&#39;ATS51={value}&#39;)
        if response[0] == &#39;OK&#39;:
            self._wakeup_period = value
    
    @property
    def gnss_refresh_interval(self) -&gt; int:
        response = self.atcommand(f&#39;ATS55?&#39;)
        if response[0] != &#39;ERROR&#39;:
            return int(response[0])

    @gnss_refresh_interval.setter
    def gnss_refresh_interval(self, value: int):
        self.gnss_continuous_set(value)

    def gnss_continuous_set(self,
                            interval: int = 0,
                            doppler: bool = True,
                            ) -&gt; bool:
        &#34;&#34;&#34;Sets the GNSS continous mode (0 = on-demand).
        
        Args:
            interval: Seconds between GNSS refresh.
            doppler: Often required for moving assets.
        
        Returns:
            True if successful setting.
        &#34;&#34;&#34;
        if interval &lt; 0 or interval &gt; 30:
            raise ValueError(&#39;GNSS continuous interval must be in range 0..30&#39;)
        response = self.atcommand(f&#39;AT%TRK={interval}{&#34;,1&#34; if doppler else &#34;&#34;}&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True

    def gnss_nmea_get(self,
                      stale_secs: int = GNSS_STALE_SECS,
                      wait_secs: int = GNSS_WAIT_SECS,
                      nmea: &#39;list[str]&#39; = [&#39;RMC&#39;, &#39;GSA&#39;, &#39;GGA&#39;, &#39;GSV&#39;],
                      ) -&gt; list:
        &#34;&#34;&#34;Returns a list of NMEA-formatted sentences from GNSS.

        Args:
            stale_secs: Maximum age of fix in seconds (1..600)
            wait_secs: Maximum time to wait for fix (1..600)

        Returns:
            List of NMEA sentences

        Raises:
            ValueError if parameter out of range
            AtGnssTimeout if the fix timed out
            AtException if any other error code was returned

        &#34;&#34;&#34;
        NMEA_SUPPORTED = [&#39;RMC&#39;, &#39;GGA&#39;, &#39;GSA&#39;, &#39;GSV&#39;]
        BUFFER_SECONDS = 5
        if (stale_secs not in range(1, 600+1) or
            wait_secs not in range(1, 600+1)):
            raise ValueError(&#39;stale_secs and wait_secs must be 1..600&#39;)
        sentences = &#39;&#39;
        for sentence in nmea:
            sentence = sentence.upper()
            if sentence not in NMEA_SUPPORTED:
                raise ValueError(f&#39;Unsupported NMEA sentence: {sentence}&#39;)
            if len(sentences) &gt; 0:
                sentences += &#39;,&#39;
            sentences += f&#39;&#34;{sentence}&#34;&#39;
        timeout = wait_secs + BUFFER_SECONDS
        request_time = time()
        response = self.atcommand(f&#39;AT%GPS={stale_secs}&#39;
                                        f&#39;,{wait_secs},{sentences}&#39;,
                                        timeout=timeout,
                                        filter=[&#39;%GPS:&#39;])
        if response[0] == &#39;ERROR&#39;:
            if self.error_detail:
                if &#39;TIMEOUT&#39; in response[1]:
                    raise AtGnssTimeout(response[1])
            self._handle_at_exception(response)
        response.remove(&#39;OK&#39;)
        time_to_fix = round(time() - request_time, 3)
        if &#39;gnss_ttf&#39; not in self._statistics:
            self._statistics[&#39;gnss_ttf&#39;] = time_to_fix
        else:
            old_ttf = self._statistics[&#39;gnss_ttf&#39;]
            avg_ttf = round((time_to_fix + old_ttf) / 2, 3)
            self._statistics[&#39;gnss_ttf&#39;] = avg_ttf
        return response

    @property
    def location(self) -&gt; &#39;Location|None&#39;:
        try:
            nmea_sentences = self.gnss_nmea_get(self._loc_query[&#39;stale_secs&#39;],
                                                self._loc_query[&#39;wait_secs&#39;])
            return location_from_nmea(nmea_sentences)
        except:
            return None

    def message_mo_send(self,
                        data: &#39;bytes|bytearray|str&#39;,
                        data_format: int = DataFormat.BASE64,
                        name: str = None,
                        priority: int = MessagePriority.LOW,
                        sin: int = None,
                        min: int = None,
                        ) -&gt; str:
        &#34;&#34;&#34;Submits a mobile-originated message to send.

        When submitting raw bytes, the first byte will be used as SIN. The
        first byte must not be in the reserved range (0..15).
        When submitting a string, the `sin` field is expected to be set and
        the data field will be appended to the `sin` byte and optionally the
        `min` byte if specified.
        
        Args:
            data: The data raw bytes or UTF-8 Text, Hexadecimal or Base64 string
            data_format: 1=text, 2=hexadecimal, 3=base64 (default)
            name: Optional unique name up to 8 characters long. If none is
                specified, use the 8 least-significant digits of unix timestamp.
            priority: 1=high, 4=low (default)
            sin: Optional first byte of payload used for codec, required if data
                is string type.
            min: Optional second byte of payload used for codec

        Returns:
            Name of the message if successful, or the error string.
        
        Raises:
            AtException if an error was returned by the modem.

        &#34;&#34;&#34;
        name = str(int(time()))[-8:] if not name else name[0:8]
        if isinstance(data, bytes) or isinstance(data, bytearray):
            sin = data[0]
            data = b64encode(data[1:]).decode(&#39;utf-8&#39;)
            data_format = DataFormat.BASE64
        elif not isinstance(data, str):
            raise ValueError(&#39;Invalid data must be bytes, bytearray or string&#39;)
        elif not isinstance(sin, int) or sin not in range(16, 256):
            raise ValueError(&#39;Invalid SIN must be 16..255&#39;)
        if isinstance(min, int) and min not in range(0, 256):
            raise ValueError(&#39;Invalid MIN must be 0..255&#39;)
        min = f&#39;.{min}&#39; if min is not None else &#39;&#39;
        data = f&#39;&#34;{data}&#34;&#39; if data_format == DataFormat.TEXT else data
        command = f&#39;AT%MGRT=&#34;{name}&#34;,{priority},{sin}{min},{data_format},{data}&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return name

    def message_mo_state(self, name: str = None) -&gt; &#39;list[dict]&#39;:
        &#34;&#34;&#34;Returns the message state(s) requested.
        
        If no name filter is passed in, all available messages states
        are returned.  Returns False is the request failed.

        Args:
            name: The unique message name in the modem queue. If none is
                provided, all available message states in transmit queue will be
                returned.

        Returns:
            List of metadata for each message in transmit queue including:
            - `name` (str) The ID in the modem transmit queue
            - `state` (int) The state of the message
            - `state_name` (str) The `MessageState.name`
            - `size` (int) in bytes
            - `sent` (int) in bytes for large message progress

        &#34;&#34;&#34;
        states = []
        name = f&#39;=&#34;{name}&#34;&#39; if name is not None else &#39;&#39;
        response = self.atcommand(f&#39;AT%MGRS{name}&#39;, filter=[&#39;%MGRS:&#39;])
        # %MGRS: &#34;&lt;name&gt;&#34;,&lt;msg_no&gt;,&lt;priority&gt;,&lt;sin&gt;,&lt;state&gt;,&lt;size&gt;,&lt;sent_bytes&gt;
        if response[0] != &#39;ERROR&#39;:
            response.remove(&#39;OK&#39;)
            for msg in response:
                if &#39;,&#39; in msg:
                    detail = msg.split(&#39;,&#39;)
                    states.append({
                        &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                        &#39;state&#39;: int(detail[4]),
                        &#39;state_name&#39;: MessageState(int(detail[4])).name,
                        &#39;size&#39;: int(detail[5]),
                        &#39;sent&#39;: int(detail[6]),
                    })
        return states
    
    def message_mo_cancel(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Cancels a mobile-originated message in the Tx ready state.&#34;&#34;&#34;
        response = self.atcommand(f&#39;AT%MGRC=&#34;{name}&#34;&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True

    def message_mo_clear(self) -&gt; int:
        &#34;&#34;&#34;Clears the modem transmit queue and returns the count cancelled.
        
        Returns:
            Count of messages deleted, or -1 in case of error

        &#34;&#34;&#34;
        list_response = self.atcommand(&#39;AT%MGRL&#39;, filter=[&#39;%MGRL:&#39;])
        if list_response[0] == &#39;ERROR&#39;:
            return -1
        message_count = len(list_response)
        for msg in list_response:
            del_response = self.atcommand(f&#39;AT%MGRD={msg}C&#39;)
            if del_response[0] == &#39;ERROR&#39;:
                _log.error(f&#39;Error clearing messages from transmit queue&#39;)
                return -1
        return message_count

    def message_mt_waiting(self) -&gt; &#39;list[dict]&#39;:
        &#34;&#34;&#34;Returns a list of received mobile-terminated message information.
        
        Returns:
            List of message metadata in the receive queue including:
            - `name` (str)
            - `sin` (int) first byte of payload
            - `priority` (int)
            - `state` (int) The state number
            - `state_name` (str) The `MessageState.name`
            - `size` (int) in bytes
            - `received` (int) in bytes for large message progress

        &#34;&#34;&#34;
        waiting = []
        response = self.atcommand(&#39;AT%MGFN&#39;, filter=[&#39;%MGFN:&#39;])
        #: %MGFN: &#34;name&#34;,number,priority,sin,state,length,bytes_received
        if response[0] != &#39;ERROR&#39;:
            response.remove(&#39;OK&#39;)
            for msg in response:
                if (&#39;,&#39; in msg):
                    detail = msg.split(&#39;,&#39;)
                    waiting.append({
                        &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                        &#39;sin&#39;: int(detail[3]),
                        &#39;priority&#39;: int(detail[2]),
                        &#39;state&#39;: int(detail[4]),
                        &#39;state_name&#39;: MessageState(int(detail[4])).name,
                        &#39;size&#39;: int(detail[5]),
                        &#39;received&#39;: int(detail[6])
                        })
        return waiting

    def message_mt_get(self,
                       name: str,
                       data_format: int = DataFormat.BASE64,
                       meta: bool = False,
                       ) -&gt; &#39;bytes|dict&#39;:
        &#34;&#34;&#34;Returns the payload of a specified mobile-terminated message.
        
        Payload is presented as a string with encoding based on data_format. 

        Args:
            name: The unique name in the modem queue e.g. FM01.01
            data_format: text=1, hex=2, base64=3 (default)
            meta: If False returns raw bytes, else returns formatted data
                with metadata.

        Returns:
            The raw data bytes if meta is False, or a dictionary with:
            - `name` (str) The name assigned by the modem
            - `system_message_number` (int) System-assigned number
            - `system_message_sequence` (int) System-assigned number
            - `sin` (int) First byte of payload
            - `priority` (int)
            - `state` (int) The message state number
            - `state_name` (str) The `MessageState.name`
            - `size` (int) in bytes
            - `data_format` (int) 1=text, 2=hex, 3=base64
            - `data` (str) presented based on data_format

        &#34;&#34;&#34;
        if not meta and data_format != DataFormat.BASE64:
            data_format = DataFormat.BASE64
        response = self.atcommand(f&#39;AT%MGFG=&#34;{name}&#34;,{data_format}&#39;)
        if response[0] == &#39;ERROR&#39;:
            _log.error(f&#39;Error retrieving message {name}&#39;)
            self._handle_at_exception(response)
        #: name, number, priority, sin, state, length, data_format, data
        try:
            detail = response[0].split(&#39;,&#39;)
            sys_msg_num, sys_msg_seq = detail[1].split(&#39;.&#39;)
            msg_sin = int(detail[3])
            data_str_no_sin = detail[7]
            if data_format == DataFormat.HEX:
                data = hex(msg_sin) + data_str_no_sin.lower()
            elif data_format == DataFormat.BASE64:
                # add SIN byte to base64 blob
                databytes = bytes([msg_sin]) + b64decode(data_str_no_sin)
                if not meta:
                    return databytes
                data = b64encode(databytes).decode(&#39;ascii&#39;)
            elif data_format == DataFormat.TEXT:
                data = f&#39;\\{msg_sin:02x}&#39; + data_str_no_sin
            return {
                &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                &#39;system_message_number&#39;: int(sys_msg_num),
                &#39;system_message_sequence&#39;: int(sys_msg_seq),
                &#39;priority&#39;: int(detail[2]),
                &#39;sin&#39;: msg_sin,
                &#39;state&#39;: int(detail[4]),
                &#39;state_name&#39;: MessageState(int(detail[4])).name,
                &#39;size&#39;: int(detail[5]),
                &#39;data_format&#39;: data_format,
                &#39;data&#39;: data
            }
        except Exception as err:
            _log.exception(err)

    def message_mt_delete(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Marks a Return message for deletion by the modem.
        
        Args:
            name: The unique mobile-terminated name in the queue

        Returns:
            True if the operation succeeded

        &#34;&#34;&#34;
        response = self.atcommand(f&#39;AT%MGFM=&#34;{name}&#34;&#39;)
        if response[0] == &#39;ERROR&#39;:
            err = f&#39; ({response[1]})&#39; if self.error_detail else &#39;&#39;
            _log.error(f&#39;Error deleting message {name}{err}&#39;)
        return response[0] == &#39;OK&#39;

    @property
    def transmitter_status(self):
        response = self.atcommand(&#39;ATS54?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return TransmitterStatus(int(response[0]))

    def _trace_detail(self) -&gt; dict:
        response = self.atcommand(&#39;AT%EVMON&#39;, filter=[&#39;%EVMON:&#39;])
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        events = response[0].split(&#39;,&#39;)
        detail = {
            &#39;monitored&#39;: [],
            &#39;cached&#39;: [],
        }
        for event in events:
            trace_class = int(event.split(&#39;.&#39;)[0])
            trace_subclass = int(event.split(&#39;.&#39;)[1].replace(&#39;*&#39;, &#39;&#39;))
            detail[&#39;monitored&#39;].append((trace_class, trace_subclass))
            if event.endswith(&#39;*&#39;):
                detail[&#39;cached&#39;].append((trace_class, trace_subclass))
        return detail

    @property
    def trace_event_monitor(self) -&gt; &#39;list[(int, int)]&#39;:
        return self._trace_detail()[&#39;monitored&#39;]
        
    @trace_event_monitor.setter
    def trace_event_monitor(self, events: &#39;list[(int, int)]&#39;):
        command = &#39;AT%EVMON=&#39;
        for event in events:
            trace_class, trace_subclass = event
            if command != &#39;AT%EVMON=&#39;:
                command += &#39;,&#39;
            command += f&#39;{trace_class}.{trace_subclass}&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)

    @property
    def trace_events_cached(self) -&gt; list:
        return self._trace_detail()[&#39;cached&#39;]

    def trace_event_get(self,
                        event: &#39;tuple[int, int]&#39;,
                        meta: bool = False,
                        ) -&gt; &#39;str|dict&#39;:
        &#34;&#34;&#34;Gets the cached event by class/subclass.

        NOTE: Metadata feature is experimental.

        Args:
            event: tuple of (class, subclass)
            meta: Returns the raw text string if False (default)
        
        Returns:
            String if raw is True or metadata dictionary including:
            - `data_count` (int)
            - `signed_bitmask` (str)
            - `mobile_id` (str)
            - `timestamp` (str)
            - `class` (str)
            - `subclass` (str)
            - `priority` (str)
            - `data` (str)
        
        Raises:
            AtException

        &#34;&#34;&#34;
        def signed32(n: int) -&gt; int:
            &#34;&#34;&#34;Converts an integer to signed 32-bit format.&#34;&#34;&#34;
            n = n &amp; 0xffffffff
            return (n ^ 0x80000000) - 0x80000000
        def event_timestamp(log_timestamp: int) -&gt; int:
            offset = int(datetime(2001, 1, 1, tzinfo=timezone.utc).timestamp())
            return log_timestamp + offset
        if not (isinstance(event, tuple) and len(event) == 2):
            raise ValueError(&#39;event_get expects (class, subclass)&#39;)
        trace_class, trace_subclass = event
        response = self.atcommand(f&#39;AT%EVNT={trace_class},{trace_subclass}&#39;,
                                  filter=[&#39;%EVNT:&#39;])
        #: res %EVNT: &lt;dataCount&gt;,&lt;signedBitmask&gt;,&lt;MTID&gt;,&lt;timestamp&gt;,
        # &lt;class&gt;,&lt;subclass&gt;,&lt;priority&gt;,&lt;data0&gt;,&lt;data1&gt;,..,&lt;dataN&gt;
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        if not meta:
            return response[0]
        eventdata = response[0].split(&#39;,&#39;)
        event = {
            &#39;data_count&#39;: int(eventdata[0]),
            &#39;signed_bitmask&#39;: bin(int(eventdata[1])),
            &#39;timestamp&#39;: event_timestamp(int(eventdata[3])),
            &#39;class&#39;: int(eventdata[4]),
            &#39;subclass&#39;: int(eventdata[5]),
            &#39;priority&#39;: int(eventdata[6]),
            &#39;data&#39;: eventdata[7:]
        }
        iso_time = datetime.utcfromtimestamp(event[&#39;timestamp&#39;]).isoformat()
        event[&#39;isotime&#39;] = iso_time[:19] + &#39;Z&#39;
        bitmask = event[&#39;signed_bitmask&#39;][2:]
        while len(bitmask) &lt; event[&#39;data_count&#39;]:
            bitmask = &#39;0&#39; + bitmask
        for i, bit in enumerate(reversed(bitmask)):
            if bit == &#39;1&#39;:
                event[&#39;data&#39;][i] = signed32(int(event[&#39;data&#39;][i]))
            else:
                event[&#39;data&#39;][i] = int(event[&#39;data&#39;][i])
        # TODO lookup class/subclass definitions
        for trace_def in EVENT_TRACES:
            if trace_def.trace_class != trace_class:
                continue
            if trace_def.trace_subclass != trace_subclass:
                continue
            try:
                for i, value in enumerate(event[&#39;data&#39;]):
                    tag, data_type = trace_def.data[i]
                    new_value = value
                    if &#39;flags&#39; in tag and isinstance(data_type, dict):
                        new_value = []
                        for flag in data_type:
                            if flag &amp; value:
                                new_value.append(data_type[flag])
                    elif str(tag).endswith(&#39;_state&#39;):
                        if isinstance(data_type, dict):
                            new_value = data_type[value]
                        else:
                            try:   #: IntEnum
                                new_value = data_type(value)
                            except:
                                pass   # new_value stays as value
                    event[&#39;data&#39;][i] = { tag: new_value }
            except Exception as err:
                _log.exception(err)
        return event

    @staticmethod
    def _list_events(bitmask: int) -&gt; &#39;list[EventNotification]&#39;:
        events = []
        for notification in EventNotification:
            if bitmask &amp; notification == notification:
                events.append(notification)
        return events

    @property
    def event_notification_monitor(self) -&gt; &#39;list[EventNotification]&#39;:
        response = self.atcommand(&#39;ATS88?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return self._list_events(int(response[0]))
    
    @event_notification_monitor.setter
    def event_notification_monitor(self, event_list: &#39;list[EventNotification]&#39;):
        bitmask = 0
        for event in event_list:
            bitmask = bitmask | event
        response = self.atcommand(f&#39;ATS88={bitmask}&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)

    @property
    def event_notifications(self) -&gt; &#39;list[EventNotification]&#39;:
        response = self.atcommand(&#39;ATS89?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return self._list_events(int(response[0]))
    
    @property
    def control_state(self) -&gt; &#39;int|None&#39;:
        self.satellite_status_get()
        return SatlliteControlState(self._ctrl_state)
    
    @property
    def network_status(self) -&gt; &#39;str|None&#39;:
        if self._ctrl_state is None:
            self.satellite_status_get()
        return SatlliteControlState(self._ctrl_state).name

    @property
    def beamsearch_state(self) -&gt; &#39;int|None&#39;:
        self.satellite_status_get()
        return BeamSearchState(self._beamsearch_state)
    
    @property
    def beamsearch(self) -&gt; &#39;str|None&#39;:
        if self._beamsearch_state is None:
            self.satellite_status_get()
        return BeamSearchState(self._beamsearch_state).name

    @property
    def snr(self) -&gt; &#39;float|None&#39;:
        self.satellite_status_get()
        return self._snr
            
    @property
    def satellite(self) -&gt; &#39;str|None&#39;:
        if self._geo_beam_id is None:
            self.satellite_status_get()
        if self._geo_beam_id is not None:
            if self._geo_beam_id in GEOBEAMS:
                return GEOBEAMS[self._geo_beam_id].split(&#39; &#39;)[0]
            return f&#39;UNDEFINED {self._geo_beam_id}&#39;
    
    @property
    def beam_id(self) -&gt; &#39;str|None&#39;:
        if self._geo_beam_id is None:
            self.satellite_status_get()
        if self._geo_beam_id is not None:
            if self._geo_beam_id in GEOBEAMS:
                return GEOBEAMS[self._geo_beam_id].split(&#39; &#39;)[1]
            return f&#39;GEO{self._geo_beam_id}&#39;
        
    def satellite_status_get(self) -&gt; dict:
        &#34;&#34;&#34;Returns the control state and C/No.
        
        Returns:
            Dictionary including:
            - `satellite` (str)
            - `beam_id` (str)
            - `network_status` (str)
            - `control_state` (int)
            - `beamsearch` (str)
            - `beamsearch_state` (int)
            - `snr` (float)
        
        &#34;&#34;&#34;
        if (&#39;sat_status&#39; in self._holdoffs and
            int(time()) - self._holdoffs[&#39;sat_status&#39;] &lt; SAT_STATUS_HOLDOFF):
            _log.debug(&#39;Ignoring repeat satellite status query&#39;)
            return
        _log.debug(&#39;Querying satellite status&#39;)
        self._holdoffs[&#39;sat_status&#39;] = int(time())
        # Trace events:
        #   Class 3 Subclass 1 C/N, Satellite Control State, Beam Search State
        #   Class 3 Subclass 5 Geo Beam ID
        command = (&#39;ATS90=3 S91=1 S92=1 S116? S122? S123?&#39;
                   &#39; S90=3 S91=5 S92=1 S102?&#39;)
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        self._snr = round(int(response[0]) / 100.0, 2)
        self._ctrl_state = int(response[1])
        self._beamsearch_state = int(response[2])
        self._geo_beam_id = int(response[3])
        return {
            &#39;satellite&#39;: self.satellite,
            &#39;beam_id&#39;: self.beam_id,
            &#39;network_status&#39;: self.network_status,
            &#39;control_state&#39;: self._ctrl_state,
            &#39;beamsearch&#39;: self.beamsearch,
            &#39;beamsearch_state&#39;: self._beamsearch_state,
            &#39;snr&#39;: self._snr,
        }

    def shutdown(self) -&gt; bool:
        &#34;&#34;&#34;Tell the modem to prepare for power-down.&#34;&#34;&#34;
        _log.warning(&#39;Attempting to shut down&#39;)
        response = self.atcommand(&#39;AT%OFF&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return True

    def utc_time(self) -&gt; str:
        &#34;&#34;&#34;Returns current UTC time of the modem in ISO8601 format.&#34;&#34;&#34;
        _log.debug(&#39;Querying system time&#39;)
        response = self.atcommand(&#39;AT%UTC&#39;, filter=[&#39;%UTC:&#39;])
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return response[0].replace(&#39; &#39;, &#39;T&#39;) + &#39;Z&#39;

    def s_register_get(self, register: &#39;str|int&#39;) -&gt; int:
        &#34;&#34;&#34;Returns the value of the S-register requested.

        Args:
            register: The register name/number (e.g. S80)

        Returns:
            integer value or None
        &#34;&#34;&#34;
        if isinstance(register, str):
            try:
                register = int(register.replace(&#39;S&#39;, &#39;&#39;))
            except ValueError:
                raise ValueError(f&#39;Invalid S-register {register}&#39;)
        _log.debug(f&#39;Querying S-register {register}&#39;)
        response = self.atcommand(f&#39;ATS{register}?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return int(response[0])

    def _s_registers_read(self) -&gt; None:
        command = &#39;AT&#39;
        for reg in self.s_registers:
            if command != &#39;AT&#39;:
                command += &#39; &#39;
            command += f&#39;{reg}?&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            _log.error(&#39;Could not read S-registers&#39;)
            raise
        index = 0
        for name, register in self.s_registers.items():
            register.value = response[index]
            index += 1

    def s_register_get_definitions(self) -&gt; list:
        &#34;&#34;&#34;Returns a list of S-register definitions.
        R=read-only, S=signed, V=volatile
        
        Returns:
            tuple(register, RSV, current, default, minimum, maximum) or None
        &#34;&#34;&#34;
        raise NotImplementedError
        #: AT%SREG
        #: Sreg, RSV, CurrentVal, DefaultVal, MinimumVal, MaximumVal
        response = self.atcommand(&#39;AT%SREG&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        response.remove(&#39;OK&#39;)
        # header_rows = response[0:1]
        # Sreg RSV CurrentVal NvmValue DefaultValue MinimumValue MaximumVal
        reg_defs = response[2:]
        registers = []
        for row in reg_defs:
            reg_def = row.split(&#39; &#39;)
            reg_def = tuple(filter(None, reg_def))
            registers.append(reg_def)
        return registers</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="idpmodem.asyncio.modem.AtConfiguration"><code class="flex name class">
<span>class <span class="ident">AtConfiguration</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AtConfiguration:
    def __init__(self) -&gt; None:
        self.crc: bool = False
        self.echo: bool = True
        self.quiet: bool = False
        self.verbose: bool = True</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem"><code class="flex name class">
<span>class <span class="ident">IdpModem</span></span>
<span>(</span><span>serial_port:Â str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A protocol factory abstracting AT commands for an IDP modem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdpModem:
    &#34;&#34;&#34;A protocol factory abstracting AT commands for an IDP modem.&#34;&#34;&#34;
    
    SERIAL_KWARGS = [&#39;baudrate&#39;, &#39;timeout&#39;, &#39;write_timeout&#39;]
    BAUD_RATES = [1200, 2400, 4800, 9600, 19200]
    PROTOCOL_KWARGS = [&#39;event_callback&#39;, &#39;at_timeout&#39;]
    OTHER_KWARGS = [&#39;error_detail&#39;, &#39;debug&#39;, &#39;stale_secs&#39;, &#39;wait_secs&#39;]
    
    def __init__(self, serial_port: str, **kwargs):
        self.serial_kwargs = {
            &#39;port&#39;: serial_port,
            &#39;baudrate&#39;: int(kwargs.pop(&#39;baudrate&#39;, 9600)),
        }
        self.protocol_kwargs = {}
        self.error_detail = bool(kwargs.pop(&#39;error_detail&#39;, True))
        self.debug = bool(kwargs.pop(&#39;debug&#39;, False))
        for kwarg in kwargs:
            if kwarg in self.SERIAL_KWARGS:
                self.serial_kwargs[kwarg] = kwargs[kwarg]
            elif kwarg in self.PROTOCOL_KWARGS:
                self.protocol_kwargs[kwarg] = kwargs[kwarg]
        self.loop = asyncio.get_event_loop()
        self.coro = serial_asyncio.create_serial_connection(
            self.loop,
            protocol_factory=AtProtocol,
            **self.serial_kwargs
        )
        self.serial_port = None
        self.transport = None
        self.protocol = None
        self.commands = queue.Queue(1)
        self._at_config = AtConfiguration()
        self._mobile_id: str = None
        self._versions: dict = None
        self._power_mode: int = None
        self._wakeup_period: int = None
        self._ctrl_state: int = None
        self._snr: float = None
        self._geo_beam_id: int = None
        self._beamsearch_state: int = None
        self._loc_query: dict = {
            &#39;stale_secs&#39;: int(kwargs.pop(&#39;stale_secs&#39;, GNSS_STALE_SECS)),
            &#39;wait_secs&#39;: int(kwargs.pop(&#39;wait_secs&#39;, GNSS_WAIT_SECS)),
        }
        self._holdoffs: dict = {}   # used to ignore frequent repeat commands
        self._statistics: dict = {}
        self.s_registers = SRegisters()
        # self.tx_queue = queue.Queue()
        # self.tx_complete_callback: callable = None
        # self.rx_queue = queue.Queue()
        # self.rx_received_callback: callable = None
    
    def connect(self):
        self.transport, self.protocol = self.loop.run_until_complete(self.coro)
        self.loop.run_forever()
        _log.debug(f&#39;Transport: {self.transport}&#39;)
        # self.serial_port = Serial(**self.serial_kwargs)

    def disconnect(self):
        self.loop.close()
        self.transport = None
        self.protocol = None
    
    @property
    def connected(self) -&gt; bool:
        return self.transport is not None and self.protocol is not None

    @property
    def baudrate(self) -&gt; &#39;int|None&#39;:
        return self.transport.baudrate if self.transport else None
    
    @baudrate.setter
    def baudrate(self, value: int):
        if not self.connected:
            raise ConnectionError(&#39;Modem is not connected&#39;)
        if value not in self.BAUD_RATES:
            raise ValueError(f&#39;Baud rate must be one of {self.BAUD_RATES}&#39;)
        response = self.atcommand(f&#39;AT+IPR={value}&#39;)
        if response and response[0] != &#39;ERROR&#39;:
            self.serial_port.baudrate = value

    @property
    def crc(self) -&gt; &#39;bool|None&#39;:
        return self.protocol.crc if self.protocol is not None else None

    def atcommand(self,
                  command: str,
                  filter: &#39;list[str]&#39; = [],
                  timeout: int = 5,
                  await_previous: bool = True,
                  ) -&gt; &#39;list[str]&#39;:
        &#34;&#34;&#34;Sends an AT command to the modem and returns the response.
        
        Args:
            command: The AT command
            filter: (optional) list of sub/strings to remove from response.
            timeout: Number of seconds to wait for a reply
                (not including messages queued by other threads)
            await_previous: If True, this will block if a prior command was
                submitted by another thread
        
        Returns:
            list of filtered and stripped response(s) to the command(s)
        
        Raises:
            ModemBusy if await_previous is False and a prior command is queued.
            AtException if an error occurred that is unrecognized.

        &#34;&#34;&#34;
        if not self.connected:
            raise ConnectionError(&#39;No connection to IDP modem&#39;)
        while self.commands.full():
            if not await_previous:
                raise ModemBusy
            pass
        self.commands.put(command)
        # TODO: allow for async(?)
        res: list = self.protocol.command(command, filter, timeout, self.debug)
        if self.error_detail and res and res[0] == &#39;ERROR&#39;:
            _log.error(f&#39;Error received for command {command}&#39;)
            err_res = self.protocol.command(&#39;ATS80?&#39;)
            if not err_res or err_res[0] == &#39;ERROR&#39;:
                raise AtException(&#39;Unhandled error getting last error code&#39;)
            last_err_code = err_res[0]
            detail = &#39;UNDEFINED&#39;
            if int(last_err_code) in AT_ERROR_CODES:
                detail = AT_ERROR_CODES[int(last_err_code)]
            res.append(f&#39;{detail} ({last_err_code})&#39;)
        self.commands.get()
        self.commands.task_done()
        return res
    
    def _handle_at_exception(self, response: &#39;list[str]&#39;) -&gt; None:
        err = response[1] if self.error_detail else response[0]
        raise AtException(err)

    def config_init(self, crc: bool = False) -&gt; bool:
        &#34;&#34;&#34;Initializes modem communications with Echo, Verbose. CRC optional.&#34;&#34;&#34;
        def attempt(command: str) -&gt; bool:
            response = self.atcommand(command)
            return response[0] == &#39;OK&#39;
        # try at most twice
        command = f&#39;ATZ;E1;V1;Q0;%CRC={1 if crc else 0}&#39;
        success = attempt(command)
        if not success:
            success = attempt(command)
        if success:
            self.protocol.crc = crc
            self._at_config.crc = crc
        return success

    def config_restore_nvm(self) -&gt; bool:
        &#34;&#34;&#34;Sends ATZ to restore config from non-volatile memory.&#34;&#34;&#34;
        response = self.atcommand(&#39;ATZ&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True

    def config_restore_factory(self) -&gt; bool:
        &#34;&#34;&#34;Sends AT&amp;F to restore factory default and returns True on success.&#34;&#34;&#34;
        response = self.atcommand(&#39;AT&amp;F&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True
    
    def config_report(self) -&gt; &#39;tuple[dict, dict]&#39;:
        &#34;&#34;&#34;Sends the AT&amp;V command to retrieve S-register settings.
        
        Returns:
            A tuple with two dictionaries (empty if failed) with:
            at_config with booleans crc, echo, quiet and verbose
            reg_config with S-register tags and integer values
        
        Raises:
            AtException if an error was returned.

        &#34;&#34;&#34;
        response = self.atcommand(&#39;AT&amp;V&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        at_config = response[1]
        s_regs = response[2]
        echo, quiet, verbose, crc = at_config.split(&#39; &#39;)
        self._at_config.crc = bool(int(crc[4]))
        self._at_config.echo = bool(int(echo[1]))
        self._at_config.quiet = bool(int(quiet[1]))
        self._at_config.verbose = bool(int(verbose[1]))
        reg_config = {}
        for reg in s_regs.split(&#39; &#39;):
            name, value = reg.split(&#39;:&#39;)
            reg_config[name] = int(value)
        return (at_config, reg_config)

    def config_volatile_report(self) -&gt; &#39;dict|None&#39;:
        &#34;&#34;&#34;Returns key S-register settings.
        
        GNSS Mode (S39), GNSS fix timeout (S41), GNSS Continuous (S55),
        GNSS Jamming Status (S56), GNSS Jamming Indicator (S57), 
        Low power Wakeup Period (S51)

        Returns:
            Dictionary of S-register values, or None if failed
            
        &#34;&#34;&#34;
        register_list = [
            &#39;S39&#39;,   #: GNSS Mode
            &#39;S41&#39;,   #: GNSS Fix Timeout
            &#39;S51&#39;,   #: Wakeup Interval
            &#39;S55&#39;,   #: GNSS Continuous
            &#39;S56&#39;,   #: GNSS Jamming Status
            &#39;S57&#39;,   #: GNSS Jamming Indicator
        ]
        command = &#39;AT&#39;
        for reg in register_list:
            command += f&#39;{reg if command == &#34;AT&#34; else &#34; &#34; + reg}?&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            return None
        #: else
        response.remove(&#39;OK&#39;)
        volatile_regs = {}
        for r in range(len(response)):
            volatile_regs[register_list[r]] = int(response[r])
        return volatile_regs

    def config_nvm_save(self) -&gt; bool:
        &#34;&#34;&#34;Sends the AT&amp;W command and returns True if successful.&#34;&#34;&#34;
        response = self.atcommand(&#39;AT&amp;W&#39;)
        return response[0] == &#39;OK&#39;

    def crc_enable(self, enable: bool = True) -&gt; bool:
        &#34;&#34;&#34;Sends the AT%CRC command and returns success flag.
        
        Args:
            enable: turn on CRC if True else turn off

        Returns:
            True if the operation succeeded else False

        &#34;&#34;&#34;
        command = f&#39;AT%CRC={1 if enable else 0}&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            return False
        self.protocol.crc = enable
        self._at_config.crc = enable
        return True

    @property
    def mobile_id(self) -&gt; &#39;str|None&#39;:
        &#34;&#34;&#34;Returns the unique Mobile ID (Inmarsat serial number).&#34;&#34;&#34;
        if self._mobile_id is None:
            response = self.atcommand(&#39;AT+GSN&#39;, filter=[&#39;+GSN:&#39;])
            if response[0] != &#39;ERROR&#39;:
                self._mobile_id = response[0]
        return self._mobile_id

    @property
    def versions(self) -&gt; &#39;dict|None&#39;:
        &#34;&#34;&#34;Returns the hardware, firmware and AT versions.&#34;&#34;&#34;
        if not self._versions:
            response = self.atcommand(&#39;AT+GMR&#39;, filter=[&#39;+GMR:&#39;])
            if response[0] != &#39;ERROR&#39;:
                fw_ver, hw_ver, at_ver = response[0].split(&#39;,&#39;)
                self._versions = {
                    &#39;hardware&#39;: hw_ver,
                    &#39;firmware&#39;: fw_ver,
                    &#39;at&#39;: at_ver,
                }
        return self._versions

    @property
    def power_mode(self) -&gt; &#39;str|None&#39;:
        if self._power_mode is None:
            response = self.atcommand(&#39;ATS50?&#39;)
            if response[0] != &#39;ERROR&#39;:
                self._power_mode = int(response[0])
        if self._power_mode in POWER_MODES:
            return POWER_MODES[self._power_mode]
    
    @power_mode.setter
    def power_mode(self, value: &#39;str|int&#39;):
        if isinstance(value, str):
            if value not in POWER_MODES.values():
                raise ValueError(f&#39;Invalid power mode {value}&#39;)
            for k, v in POWER_MODES.items():
                if v == value:
                    value = k
                    break
        if value not in POWER_MODES:
            raise ValueError(f&#39;Invalid power mode {value}&#39;)
        response = self.atcommand(f&#39;ATS50={value}&#39;)
        if response[0] == &#39;OK&#39;:
            self._power_mode = value
    
    @property
    def wakeup_period(self) -&gt; &#39;str|None&#39;:
        if self._wakeup_period is None:
            response = self.atcommand(&#39;ATS51?&#39;)
            if response[0] != &#39;ERROR&#39;:
                self._wakeup_period = int(response[0])
        if self._wakeup_period in WAKEUP_PERIODS:
            return WAKEUP_PERIODS[self._wakeup_period]

    @wakeup_period.setter
    def wakeup_period(self, value: &#39;str|int&#39;):
        if isinstance(value, str):
            if value not in WAKEUP_PERIODS.values():
                raise ValueError(f&#39;Invalid wakeup period {value}&#39;)
            for k, v in WAKEUP_PERIODS.items():
                if v == value:
                    value = k
                    break
        if value not in WAKEUP_PERIODS:
            raise ValueError(f&#39;Invalid wakeup period {value}&#39;)
        response = self.atcommand(f&#39;ATS51={value}&#39;)
        if response[0] == &#39;OK&#39;:
            self._wakeup_period = value
    
    @property
    def gnss_refresh_interval(self) -&gt; int:
        response = self.atcommand(f&#39;ATS55?&#39;)
        if response[0] != &#39;ERROR&#39;:
            return int(response[0])

    @gnss_refresh_interval.setter
    def gnss_refresh_interval(self, value: int):
        self.gnss_continuous_set(value)

    def gnss_continuous_set(self,
                            interval: int = 0,
                            doppler: bool = True,
                            ) -&gt; bool:
        &#34;&#34;&#34;Sets the GNSS continous mode (0 = on-demand).
        
        Args:
            interval: Seconds between GNSS refresh.
            doppler: Often required for moving assets.
        
        Returns:
            True if successful setting.
        &#34;&#34;&#34;
        if interval &lt; 0 or interval &gt; 30:
            raise ValueError(&#39;GNSS continuous interval must be in range 0..30&#39;)
        response = self.atcommand(f&#39;AT%TRK={interval}{&#34;,1&#34; if doppler else &#34;&#34;}&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True

    def gnss_nmea_get(self,
                      stale_secs: int = GNSS_STALE_SECS,
                      wait_secs: int = GNSS_WAIT_SECS,
                      nmea: &#39;list[str]&#39; = [&#39;RMC&#39;, &#39;GSA&#39;, &#39;GGA&#39;, &#39;GSV&#39;],
                      ) -&gt; list:
        &#34;&#34;&#34;Returns a list of NMEA-formatted sentences from GNSS.

        Args:
            stale_secs: Maximum age of fix in seconds (1..600)
            wait_secs: Maximum time to wait for fix (1..600)

        Returns:
            List of NMEA sentences

        Raises:
            ValueError if parameter out of range
            AtGnssTimeout if the fix timed out
            AtException if any other error code was returned

        &#34;&#34;&#34;
        NMEA_SUPPORTED = [&#39;RMC&#39;, &#39;GGA&#39;, &#39;GSA&#39;, &#39;GSV&#39;]
        BUFFER_SECONDS = 5
        if (stale_secs not in range(1, 600+1) or
            wait_secs not in range(1, 600+1)):
            raise ValueError(&#39;stale_secs and wait_secs must be 1..600&#39;)
        sentences = &#39;&#39;
        for sentence in nmea:
            sentence = sentence.upper()
            if sentence not in NMEA_SUPPORTED:
                raise ValueError(f&#39;Unsupported NMEA sentence: {sentence}&#39;)
            if len(sentences) &gt; 0:
                sentences += &#39;,&#39;
            sentences += f&#39;&#34;{sentence}&#34;&#39;
        timeout = wait_secs + BUFFER_SECONDS
        request_time = time()
        response = self.atcommand(f&#39;AT%GPS={stale_secs}&#39;
                                        f&#39;,{wait_secs},{sentences}&#39;,
                                        timeout=timeout,
                                        filter=[&#39;%GPS:&#39;])
        if response[0] == &#39;ERROR&#39;:
            if self.error_detail:
                if &#39;TIMEOUT&#39; in response[1]:
                    raise AtGnssTimeout(response[1])
            self._handle_at_exception(response)
        response.remove(&#39;OK&#39;)
        time_to_fix = round(time() - request_time, 3)
        if &#39;gnss_ttf&#39; not in self._statistics:
            self._statistics[&#39;gnss_ttf&#39;] = time_to_fix
        else:
            old_ttf = self._statistics[&#39;gnss_ttf&#39;]
            avg_ttf = round((time_to_fix + old_ttf) / 2, 3)
            self._statistics[&#39;gnss_ttf&#39;] = avg_ttf
        return response

    @property
    def location(self) -&gt; &#39;Location|None&#39;:
        try:
            nmea_sentences = self.gnss_nmea_get(self._loc_query[&#39;stale_secs&#39;],
                                                self._loc_query[&#39;wait_secs&#39;])
            return location_from_nmea(nmea_sentences)
        except:
            return None

    def message_mo_send(self,
                        data: &#39;bytes|bytearray|str&#39;,
                        data_format: int = DataFormat.BASE64,
                        name: str = None,
                        priority: int = MessagePriority.LOW,
                        sin: int = None,
                        min: int = None,
                        ) -&gt; str:
        &#34;&#34;&#34;Submits a mobile-originated message to send.

        When submitting raw bytes, the first byte will be used as SIN. The
        first byte must not be in the reserved range (0..15).
        When submitting a string, the `sin` field is expected to be set and
        the data field will be appended to the `sin` byte and optionally the
        `min` byte if specified.
        
        Args:
            data: The data raw bytes or UTF-8 Text, Hexadecimal or Base64 string
            data_format: 1=text, 2=hexadecimal, 3=base64 (default)
            name: Optional unique name up to 8 characters long. If none is
                specified, use the 8 least-significant digits of unix timestamp.
            priority: 1=high, 4=low (default)
            sin: Optional first byte of payload used for codec, required if data
                is string type.
            min: Optional second byte of payload used for codec

        Returns:
            Name of the message if successful, or the error string.
        
        Raises:
            AtException if an error was returned by the modem.

        &#34;&#34;&#34;
        name = str(int(time()))[-8:] if not name else name[0:8]
        if isinstance(data, bytes) or isinstance(data, bytearray):
            sin = data[0]
            data = b64encode(data[1:]).decode(&#39;utf-8&#39;)
            data_format = DataFormat.BASE64
        elif not isinstance(data, str):
            raise ValueError(&#39;Invalid data must be bytes, bytearray or string&#39;)
        elif not isinstance(sin, int) or sin not in range(16, 256):
            raise ValueError(&#39;Invalid SIN must be 16..255&#39;)
        if isinstance(min, int) and min not in range(0, 256):
            raise ValueError(&#39;Invalid MIN must be 0..255&#39;)
        min = f&#39;.{min}&#39; if min is not None else &#39;&#39;
        data = f&#39;&#34;{data}&#34;&#39; if data_format == DataFormat.TEXT else data
        command = f&#39;AT%MGRT=&#34;{name}&#34;,{priority},{sin}{min},{data_format},{data}&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return name

    def message_mo_state(self, name: str = None) -&gt; &#39;list[dict]&#39;:
        &#34;&#34;&#34;Returns the message state(s) requested.
        
        If no name filter is passed in, all available messages states
        are returned.  Returns False is the request failed.

        Args:
            name: The unique message name in the modem queue. If none is
                provided, all available message states in transmit queue will be
                returned.

        Returns:
            List of metadata for each message in transmit queue including:
            - `name` (str) The ID in the modem transmit queue
            - `state` (int) The state of the message
            - `state_name` (str) The `MessageState.name`
            - `size` (int) in bytes
            - `sent` (int) in bytes for large message progress

        &#34;&#34;&#34;
        states = []
        name = f&#39;=&#34;{name}&#34;&#39; if name is not None else &#39;&#39;
        response = self.atcommand(f&#39;AT%MGRS{name}&#39;, filter=[&#39;%MGRS:&#39;])
        # %MGRS: &#34;&lt;name&gt;&#34;,&lt;msg_no&gt;,&lt;priority&gt;,&lt;sin&gt;,&lt;state&gt;,&lt;size&gt;,&lt;sent_bytes&gt;
        if response[0] != &#39;ERROR&#39;:
            response.remove(&#39;OK&#39;)
            for msg in response:
                if &#39;,&#39; in msg:
                    detail = msg.split(&#39;,&#39;)
                    states.append({
                        &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                        &#39;state&#39;: int(detail[4]),
                        &#39;state_name&#39;: MessageState(int(detail[4])).name,
                        &#39;size&#39;: int(detail[5]),
                        &#39;sent&#39;: int(detail[6]),
                    })
        return states
    
    def message_mo_cancel(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Cancels a mobile-originated message in the Tx ready state.&#34;&#34;&#34;
        response = self.atcommand(f&#39;AT%MGRC=&#34;{name}&#34;&#39;)
        if response[0] == &#39;ERROR&#39;:
            return False
        return True

    def message_mo_clear(self) -&gt; int:
        &#34;&#34;&#34;Clears the modem transmit queue and returns the count cancelled.
        
        Returns:
            Count of messages deleted, or -1 in case of error

        &#34;&#34;&#34;
        list_response = self.atcommand(&#39;AT%MGRL&#39;, filter=[&#39;%MGRL:&#39;])
        if list_response[0] == &#39;ERROR&#39;:
            return -1
        message_count = len(list_response)
        for msg in list_response:
            del_response = self.atcommand(f&#39;AT%MGRD={msg}C&#39;)
            if del_response[0] == &#39;ERROR&#39;:
                _log.error(f&#39;Error clearing messages from transmit queue&#39;)
                return -1
        return message_count

    def message_mt_waiting(self) -&gt; &#39;list[dict]&#39;:
        &#34;&#34;&#34;Returns a list of received mobile-terminated message information.
        
        Returns:
            List of message metadata in the receive queue including:
            - `name` (str)
            - `sin` (int) first byte of payload
            - `priority` (int)
            - `state` (int) The state number
            - `state_name` (str) The `MessageState.name`
            - `size` (int) in bytes
            - `received` (int) in bytes for large message progress

        &#34;&#34;&#34;
        waiting = []
        response = self.atcommand(&#39;AT%MGFN&#39;, filter=[&#39;%MGFN:&#39;])
        #: %MGFN: &#34;name&#34;,number,priority,sin,state,length,bytes_received
        if response[0] != &#39;ERROR&#39;:
            response.remove(&#39;OK&#39;)
            for msg in response:
                if (&#39;,&#39; in msg):
                    detail = msg.split(&#39;,&#39;)
                    waiting.append({
                        &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                        &#39;sin&#39;: int(detail[3]),
                        &#39;priority&#39;: int(detail[2]),
                        &#39;state&#39;: int(detail[4]),
                        &#39;state_name&#39;: MessageState(int(detail[4])).name,
                        &#39;size&#39;: int(detail[5]),
                        &#39;received&#39;: int(detail[6])
                        })
        return waiting

    def message_mt_get(self,
                       name: str,
                       data_format: int = DataFormat.BASE64,
                       meta: bool = False,
                       ) -&gt; &#39;bytes|dict&#39;:
        &#34;&#34;&#34;Returns the payload of a specified mobile-terminated message.
        
        Payload is presented as a string with encoding based on data_format. 

        Args:
            name: The unique name in the modem queue e.g. FM01.01
            data_format: text=1, hex=2, base64=3 (default)
            meta: If False returns raw bytes, else returns formatted data
                with metadata.

        Returns:
            The raw data bytes if meta is False, or a dictionary with:
            - `name` (str) The name assigned by the modem
            - `system_message_number` (int) System-assigned number
            - `system_message_sequence` (int) System-assigned number
            - `sin` (int) First byte of payload
            - `priority` (int)
            - `state` (int) The message state number
            - `state_name` (str) The `MessageState.name`
            - `size` (int) in bytes
            - `data_format` (int) 1=text, 2=hex, 3=base64
            - `data` (str) presented based on data_format

        &#34;&#34;&#34;
        if not meta and data_format != DataFormat.BASE64:
            data_format = DataFormat.BASE64
        response = self.atcommand(f&#39;AT%MGFG=&#34;{name}&#34;,{data_format}&#39;)
        if response[0] == &#39;ERROR&#39;:
            _log.error(f&#39;Error retrieving message {name}&#39;)
            self._handle_at_exception(response)
        #: name, number, priority, sin, state, length, data_format, data
        try:
            detail = response[0].split(&#39;,&#39;)
            sys_msg_num, sys_msg_seq = detail[1].split(&#39;.&#39;)
            msg_sin = int(detail[3])
            data_str_no_sin = detail[7]
            if data_format == DataFormat.HEX:
                data = hex(msg_sin) + data_str_no_sin.lower()
            elif data_format == DataFormat.BASE64:
                # add SIN byte to base64 blob
                databytes = bytes([msg_sin]) + b64decode(data_str_no_sin)
                if not meta:
                    return databytes
                data = b64encode(databytes).decode(&#39;ascii&#39;)
            elif data_format == DataFormat.TEXT:
                data = f&#39;\\{msg_sin:02x}&#39; + data_str_no_sin
            return {
                &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                &#39;system_message_number&#39;: int(sys_msg_num),
                &#39;system_message_sequence&#39;: int(sys_msg_seq),
                &#39;priority&#39;: int(detail[2]),
                &#39;sin&#39;: msg_sin,
                &#39;state&#39;: int(detail[4]),
                &#39;state_name&#39;: MessageState(int(detail[4])).name,
                &#39;size&#39;: int(detail[5]),
                &#39;data_format&#39;: data_format,
                &#39;data&#39;: data
            }
        except Exception as err:
            _log.exception(err)

    def message_mt_delete(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Marks a Return message for deletion by the modem.
        
        Args:
            name: The unique mobile-terminated name in the queue

        Returns:
            True if the operation succeeded

        &#34;&#34;&#34;
        response = self.atcommand(f&#39;AT%MGFM=&#34;{name}&#34;&#39;)
        if response[0] == &#39;ERROR&#39;:
            err = f&#39; ({response[1]})&#39; if self.error_detail else &#39;&#39;
            _log.error(f&#39;Error deleting message {name}{err}&#39;)
        return response[0] == &#39;OK&#39;

    @property
    def transmitter_status(self):
        response = self.atcommand(&#39;ATS54?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return TransmitterStatus(int(response[0]))

    def _trace_detail(self) -&gt; dict:
        response = self.atcommand(&#39;AT%EVMON&#39;, filter=[&#39;%EVMON:&#39;])
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        events = response[0].split(&#39;,&#39;)
        detail = {
            &#39;monitored&#39;: [],
            &#39;cached&#39;: [],
        }
        for event in events:
            trace_class = int(event.split(&#39;.&#39;)[0])
            trace_subclass = int(event.split(&#39;.&#39;)[1].replace(&#39;*&#39;, &#39;&#39;))
            detail[&#39;monitored&#39;].append((trace_class, trace_subclass))
            if event.endswith(&#39;*&#39;):
                detail[&#39;cached&#39;].append((trace_class, trace_subclass))
        return detail

    @property
    def trace_event_monitor(self) -&gt; &#39;list[(int, int)]&#39;:
        return self._trace_detail()[&#39;monitored&#39;]
        
    @trace_event_monitor.setter
    def trace_event_monitor(self, events: &#39;list[(int, int)]&#39;):
        command = &#39;AT%EVMON=&#39;
        for event in events:
            trace_class, trace_subclass = event
            if command != &#39;AT%EVMON=&#39;:
                command += &#39;,&#39;
            command += f&#39;{trace_class}.{trace_subclass}&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)

    @property
    def trace_events_cached(self) -&gt; list:
        return self._trace_detail()[&#39;cached&#39;]

    def trace_event_get(self,
                        event: &#39;tuple[int, int]&#39;,
                        meta: bool = False,
                        ) -&gt; &#39;str|dict&#39;:
        &#34;&#34;&#34;Gets the cached event by class/subclass.

        NOTE: Metadata feature is experimental.

        Args:
            event: tuple of (class, subclass)
            meta: Returns the raw text string if False (default)
        
        Returns:
            String if raw is True or metadata dictionary including:
            - `data_count` (int)
            - `signed_bitmask` (str)
            - `mobile_id` (str)
            - `timestamp` (str)
            - `class` (str)
            - `subclass` (str)
            - `priority` (str)
            - `data` (str)
        
        Raises:
            AtException

        &#34;&#34;&#34;
        def signed32(n: int) -&gt; int:
            &#34;&#34;&#34;Converts an integer to signed 32-bit format.&#34;&#34;&#34;
            n = n &amp; 0xffffffff
            return (n ^ 0x80000000) - 0x80000000
        def event_timestamp(log_timestamp: int) -&gt; int:
            offset = int(datetime(2001, 1, 1, tzinfo=timezone.utc).timestamp())
            return log_timestamp + offset
        if not (isinstance(event, tuple) and len(event) == 2):
            raise ValueError(&#39;event_get expects (class, subclass)&#39;)
        trace_class, trace_subclass = event
        response = self.atcommand(f&#39;AT%EVNT={trace_class},{trace_subclass}&#39;,
                                  filter=[&#39;%EVNT:&#39;])
        #: res %EVNT: &lt;dataCount&gt;,&lt;signedBitmask&gt;,&lt;MTID&gt;,&lt;timestamp&gt;,
        # &lt;class&gt;,&lt;subclass&gt;,&lt;priority&gt;,&lt;data0&gt;,&lt;data1&gt;,..,&lt;dataN&gt;
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        if not meta:
            return response[0]
        eventdata = response[0].split(&#39;,&#39;)
        event = {
            &#39;data_count&#39;: int(eventdata[0]),
            &#39;signed_bitmask&#39;: bin(int(eventdata[1])),
            &#39;timestamp&#39;: event_timestamp(int(eventdata[3])),
            &#39;class&#39;: int(eventdata[4]),
            &#39;subclass&#39;: int(eventdata[5]),
            &#39;priority&#39;: int(eventdata[6]),
            &#39;data&#39;: eventdata[7:]
        }
        iso_time = datetime.utcfromtimestamp(event[&#39;timestamp&#39;]).isoformat()
        event[&#39;isotime&#39;] = iso_time[:19] + &#39;Z&#39;
        bitmask = event[&#39;signed_bitmask&#39;][2:]
        while len(bitmask) &lt; event[&#39;data_count&#39;]:
            bitmask = &#39;0&#39; + bitmask
        for i, bit in enumerate(reversed(bitmask)):
            if bit == &#39;1&#39;:
                event[&#39;data&#39;][i] = signed32(int(event[&#39;data&#39;][i]))
            else:
                event[&#39;data&#39;][i] = int(event[&#39;data&#39;][i])
        # TODO lookup class/subclass definitions
        for trace_def in EVENT_TRACES:
            if trace_def.trace_class != trace_class:
                continue
            if trace_def.trace_subclass != trace_subclass:
                continue
            try:
                for i, value in enumerate(event[&#39;data&#39;]):
                    tag, data_type = trace_def.data[i]
                    new_value = value
                    if &#39;flags&#39; in tag and isinstance(data_type, dict):
                        new_value = []
                        for flag in data_type:
                            if flag &amp; value:
                                new_value.append(data_type[flag])
                    elif str(tag).endswith(&#39;_state&#39;):
                        if isinstance(data_type, dict):
                            new_value = data_type[value]
                        else:
                            try:   #: IntEnum
                                new_value = data_type(value)
                            except:
                                pass   # new_value stays as value
                    event[&#39;data&#39;][i] = { tag: new_value }
            except Exception as err:
                _log.exception(err)
        return event

    @staticmethod
    def _list_events(bitmask: int) -&gt; &#39;list[EventNotification]&#39;:
        events = []
        for notification in EventNotification:
            if bitmask &amp; notification == notification:
                events.append(notification)
        return events

    @property
    def event_notification_monitor(self) -&gt; &#39;list[EventNotification]&#39;:
        response = self.atcommand(&#39;ATS88?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return self._list_events(int(response[0]))
    
    @event_notification_monitor.setter
    def event_notification_monitor(self, event_list: &#39;list[EventNotification]&#39;):
        bitmask = 0
        for event in event_list:
            bitmask = bitmask | event
        response = self.atcommand(f&#39;ATS88={bitmask}&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)

    @property
    def event_notifications(self) -&gt; &#39;list[EventNotification]&#39;:
        response = self.atcommand(&#39;ATS89?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return self._list_events(int(response[0]))
    
    @property
    def control_state(self) -&gt; &#39;int|None&#39;:
        self.satellite_status_get()
        return SatlliteControlState(self._ctrl_state)
    
    @property
    def network_status(self) -&gt; &#39;str|None&#39;:
        if self._ctrl_state is None:
            self.satellite_status_get()
        return SatlliteControlState(self._ctrl_state).name

    @property
    def beamsearch_state(self) -&gt; &#39;int|None&#39;:
        self.satellite_status_get()
        return BeamSearchState(self._beamsearch_state)
    
    @property
    def beamsearch(self) -&gt; &#39;str|None&#39;:
        if self._beamsearch_state is None:
            self.satellite_status_get()
        return BeamSearchState(self._beamsearch_state).name

    @property
    def snr(self) -&gt; &#39;float|None&#39;:
        self.satellite_status_get()
        return self._snr
            
    @property
    def satellite(self) -&gt; &#39;str|None&#39;:
        if self._geo_beam_id is None:
            self.satellite_status_get()
        if self._geo_beam_id is not None:
            if self._geo_beam_id in GEOBEAMS:
                return GEOBEAMS[self._geo_beam_id].split(&#39; &#39;)[0]
            return f&#39;UNDEFINED {self._geo_beam_id}&#39;
    
    @property
    def beam_id(self) -&gt; &#39;str|None&#39;:
        if self._geo_beam_id is None:
            self.satellite_status_get()
        if self._geo_beam_id is not None:
            if self._geo_beam_id in GEOBEAMS:
                return GEOBEAMS[self._geo_beam_id].split(&#39; &#39;)[1]
            return f&#39;GEO{self._geo_beam_id}&#39;
        
    def satellite_status_get(self) -&gt; dict:
        &#34;&#34;&#34;Returns the control state and C/No.
        
        Returns:
            Dictionary including:
            - `satellite` (str)
            - `beam_id` (str)
            - `network_status` (str)
            - `control_state` (int)
            - `beamsearch` (str)
            - `beamsearch_state` (int)
            - `snr` (float)
        
        &#34;&#34;&#34;
        if (&#39;sat_status&#39; in self._holdoffs and
            int(time()) - self._holdoffs[&#39;sat_status&#39;] &lt; SAT_STATUS_HOLDOFF):
            _log.debug(&#39;Ignoring repeat satellite status query&#39;)
            return
        _log.debug(&#39;Querying satellite status&#39;)
        self._holdoffs[&#39;sat_status&#39;] = int(time())
        # Trace events:
        #   Class 3 Subclass 1 C/N, Satellite Control State, Beam Search State
        #   Class 3 Subclass 5 Geo Beam ID
        command = (&#39;ATS90=3 S91=1 S92=1 S116? S122? S123?&#39;
                   &#39; S90=3 S91=5 S92=1 S102?&#39;)
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        self._snr = round(int(response[0]) / 100.0, 2)
        self._ctrl_state = int(response[1])
        self._beamsearch_state = int(response[2])
        self._geo_beam_id = int(response[3])
        return {
            &#39;satellite&#39;: self.satellite,
            &#39;beam_id&#39;: self.beam_id,
            &#39;network_status&#39;: self.network_status,
            &#39;control_state&#39;: self._ctrl_state,
            &#39;beamsearch&#39;: self.beamsearch,
            &#39;beamsearch_state&#39;: self._beamsearch_state,
            &#39;snr&#39;: self._snr,
        }

    def shutdown(self) -&gt; bool:
        &#34;&#34;&#34;Tell the modem to prepare for power-down.&#34;&#34;&#34;
        _log.warning(&#39;Attempting to shut down&#39;)
        response = self.atcommand(&#39;AT%OFF&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return True

    def utc_time(self) -&gt; str:
        &#34;&#34;&#34;Returns current UTC time of the modem in ISO8601 format.&#34;&#34;&#34;
        _log.debug(&#39;Querying system time&#39;)
        response = self.atcommand(&#39;AT%UTC&#39;, filter=[&#39;%UTC:&#39;])
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return response[0].replace(&#39; &#39;, &#39;T&#39;) + &#39;Z&#39;

    def s_register_get(self, register: &#39;str|int&#39;) -&gt; int:
        &#34;&#34;&#34;Returns the value of the S-register requested.

        Args:
            register: The register name/number (e.g. S80)

        Returns:
            integer value or None
        &#34;&#34;&#34;
        if isinstance(register, str):
            try:
                register = int(register.replace(&#39;S&#39;, &#39;&#39;))
            except ValueError:
                raise ValueError(f&#39;Invalid S-register {register}&#39;)
        _log.debug(f&#39;Querying S-register {register}&#39;)
        response = self.atcommand(f&#39;ATS{register}?&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        return int(response[0])

    def _s_registers_read(self) -&gt; None:
        command = &#39;AT&#39;
        for reg in self.s_registers:
            if command != &#39;AT&#39;:
                command += &#39; &#39;
            command += f&#39;{reg}?&#39;
        response = self.atcommand(command)
        if response[0] == &#39;ERROR&#39;:
            _log.error(&#39;Could not read S-registers&#39;)
            raise
        index = 0
        for name, register in self.s_registers.items():
            register.value = response[index]
            index += 1

    def s_register_get_definitions(self) -&gt; list:
        &#34;&#34;&#34;Returns a list of S-register definitions.
        R=read-only, S=signed, V=volatile
        
        Returns:
            tuple(register, RSV, current, default, minimum, maximum) or None
        &#34;&#34;&#34;
        raise NotImplementedError
        #: AT%SREG
        #: Sreg, RSV, CurrentVal, DefaultVal, MinimumVal, MaximumVal
        response = self.atcommand(&#39;AT%SREG&#39;)
        if response[0] == &#39;ERROR&#39;:
            self._handle_at_exception(response)
        response.remove(&#39;OK&#39;)
        # header_rows = response[0:1]
        # Sreg RSV CurrentVal NvmValue DefaultValue MinimumValue MaximumVal
        reg_defs = response[2:]
        registers = []
        for row in reg_defs:
            reg_def = row.split(&#39; &#39;)
            reg_def = tuple(filter(None, reg_def))
            registers.append(reg_def)
        return registers</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="idpmodem.asyncio.modem.IdpModem.BAUD_RATES"><code class="name">var <span class="ident">BAUD_RATES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.OTHER_KWARGS"><code class="name">var <span class="ident">OTHER_KWARGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.PROTOCOL_KWARGS"><code class="name">var <span class="ident">PROTOCOL_KWARGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.SERIAL_KWARGS"><code class="name">var <span class="ident">SERIAL_KWARGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="idpmodem.asyncio.modem.IdpModem.baudrate"><code class="name">var <span class="ident">baudrate</span> :Â int|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baudrate(self) -&gt; &#39;int|None&#39;:
    return self.transport.baudrate if self.transport else None</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.beam_id"><code class="name">var <span class="ident">beam_id</span> :Â str|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beam_id(self) -&gt; &#39;str|None&#39;:
    if self._geo_beam_id is None:
        self.satellite_status_get()
    if self._geo_beam_id is not None:
        if self._geo_beam_id in GEOBEAMS:
            return GEOBEAMS[self._geo_beam_id].split(&#39; &#39;)[1]
        return f&#39;GEO{self._geo_beam_id}&#39;</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.beamsearch"><code class="name">var <span class="ident">beamsearch</span> :Â str|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beamsearch(self) -&gt; &#39;str|None&#39;:
    if self._beamsearch_state is None:
        self.satellite_status_get()
    return BeamSearchState(self._beamsearch_state).name</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.beamsearch_state"><code class="name">var <span class="ident">beamsearch_state</span> :Â int|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beamsearch_state(self) -&gt; &#39;int|None&#39;:
    self.satellite_status_get()
    return BeamSearchState(self._beamsearch_state)</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.connected"><code class="name">var <span class="ident">connected</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connected(self) -&gt; bool:
    return self.transport is not None and self.protocol is not None</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.control_state"><code class="name">var <span class="ident">control_state</span> :Â int|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def control_state(self) -&gt; &#39;int|None&#39;:
    self.satellite_status_get()
    return SatlliteControlState(self._ctrl_state)</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.crc"><code class="name">var <span class="ident">crc</span> :Â bool|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def crc(self) -&gt; &#39;bool|None&#39;:
    return self.protocol.crc if self.protocol is not None else None</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.event_notification_monitor"><code class="name">var <span class="ident">event_notification_monitor</span> :Â list[EventNotification]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_notification_monitor(self) -&gt; &#39;list[EventNotification]&#39;:
    response = self.atcommand(&#39;ATS88?&#39;)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    return self._list_events(int(response[0]))</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.event_notifications"><code class="name">var <span class="ident">event_notifications</span> :Â list[EventNotification]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_notifications(self) -&gt; &#39;list[EventNotification]&#39;:
    response = self.atcommand(&#39;ATS89?&#39;)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    return self._list_events(int(response[0]))</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.gnss_refresh_interval"><code class="name">var <span class="ident">gnss_refresh_interval</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gnss_refresh_interval(self) -&gt; int:
    response = self.atcommand(f&#39;ATS55?&#39;)
    if response[0] != &#39;ERROR&#39;:
        return int(response[0])</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.location"><code class="name">var <span class="ident">location</span> :Â Location|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def location(self) -&gt; &#39;Location|None&#39;:
    try:
        nmea_sentences = self.gnss_nmea_get(self._loc_query[&#39;stale_secs&#39;],
                                            self._loc_query[&#39;wait_secs&#39;])
        return location_from_nmea(nmea_sentences)
    except:
        return None</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.mobile_id"><code class="name">var <span class="ident">mobile_id</span> :Â str|None</code></dt>
<dd>
<div class="desc"><p>Returns the unique Mobile ID (Inmarsat serial number).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mobile_id(self) -&gt; &#39;str|None&#39;:
    &#34;&#34;&#34;Returns the unique Mobile ID (Inmarsat serial number).&#34;&#34;&#34;
    if self._mobile_id is None:
        response = self.atcommand(&#39;AT+GSN&#39;, filter=[&#39;+GSN:&#39;])
        if response[0] != &#39;ERROR&#39;:
            self._mobile_id = response[0]
    return self._mobile_id</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.network_status"><code class="name">var <span class="ident">network_status</span> :Â str|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def network_status(self) -&gt; &#39;str|None&#39;:
    if self._ctrl_state is None:
        self.satellite_status_get()
    return SatlliteControlState(self._ctrl_state).name</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.power_mode"><code class="name">var <span class="ident">power_mode</span> :Â str|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def power_mode(self) -&gt; &#39;str|None&#39;:
    if self._power_mode is None:
        response = self.atcommand(&#39;ATS50?&#39;)
        if response[0] != &#39;ERROR&#39;:
            self._power_mode = int(response[0])
    if self._power_mode in POWER_MODES:
        return POWER_MODES[self._power_mode]</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.satellite"><code class="name">var <span class="ident">satellite</span> :Â str|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def satellite(self) -&gt; &#39;str|None&#39;:
    if self._geo_beam_id is None:
        self.satellite_status_get()
    if self._geo_beam_id is not None:
        if self._geo_beam_id in GEOBEAMS:
            return GEOBEAMS[self._geo_beam_id].split(&#39; &#39;)[0]
        return f&#39;UNDEFINED {self._geo_beam_id}&#39;</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.snr"><code class="name">var <span class="ident">snr</span> :Â float|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def snr(self) -&gt; &#39;float|None&#39;:
    self.satellite_status_get()
    return self._snr</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.trace_event_monitor"><code class="name">var <span class="ident">trace_event_monitor</span> :Â list[(int,Â int)]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trace_event_monitor(self) -&gt; &#39;list[(int, int)]&#39;:
    return self._trace_detail()[&#39;monitored&#39;]</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.trace_events_cached"><code class="name">var <span class="ident">trace_events_cached</span> :Â list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trace_events_cached(self) -&gt; list:
    return self._trace_detail()[&#39;cached&#39;]</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.transmitter_status"><code class="name">var <span class="ident">transmitter_status</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transmitter_status(self):
    response = self.atcommand(&#39;ATS54?&#39;)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    return TransmitterStatus(int(response[0]))</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.versions"><code class="name">var <span class="ident">versions</span> :Â dict|None</code></dt>
<dd>
<div class="desc"><p>Returns the hardware, firmware and AT versions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def versions(self) -&gt; &#39;dict|None&#39;:
    &#34;&#34;&#34;Returns the hardware, firmware and AT versions.&#34;&#34;&#34;
    if not self._versions:
        response = self.atcommand(&#39;AT+GMR&#39;, filter=[&#39;+GMR:&#39;])
        if response[0] != &#39;ERROR&#39;:
            fw_ver, hw_ver, at_ver = response[0].split(&#39;,&#39;)
            self._versions = {
                &#39;hardware&#39;: hw_ver,
                &#39;firmware&#39;: fw_ver,
                &#39;at&#39;: at_ver,
            }
    return self._versions</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.wakeup_period"><code class="name">var <span class="ident">wakeup_period</span> :Â str|None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def wakeup_period(self) -&gt; &#39;str|None&#39;:
    if self._wakeup_period is None:
        response = self.atcommand(&#39;ATS51?&#39;)
        if response[0] != &#39;ERROR&#39;:
            self._wakeup_period = int(response[0])
    if self._wakeup_period in WAKEUP_PERIODS:
        return WAKEUP_PERIODS[self._wakeup_period]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idpmodem.asyncio.modem.IdpModem.atcommand"><code class="name flex">
<span>def <span class="ident">atcommand</span></span>(<span>self, command:Â str, filter:Â list[str]Â =Â [], timeout:Â intÂ =Â 5, await_previous:Â boolÂ =Â True) â€‘>Â list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Sends an AT command to the modem and returns the response.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>The AT command</dd>
<dt><strong><code>filter</code></strong></dt>
<dd>(optional) list of sub/strings to remove from response.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>Number of seconds to wait for a reply
(not including messages queued by other threads)</dd>
<dt><strong><code>await_previous</code></strong></dt>
<dd>If True, this will block if a prior command was
submitted by another thread</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of filtered and stripped response(s) to the command(s)</p>
<h2 id="raises">Raises</h2>
<p>ModemBusy if await_previous is False and a prior command is queued.
AtException if an error occurred that is unrecognized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atcommand(self,
              command: str,
              filter: &#39;list[str]&#39; = [],
              timeout: int = 5,
              await_previous: bool = True,
              ) -&gt; &#39;list[str]&#39;:
    &#34;&#34;&#34;Sends an AT command to the modem and returns the response.
    
    Args:
        command: The AT command
        filter: (optional) list of sub/strings to remove from response.
        timeout: Number of seconds to wait for a reply
            (not including messages queued by other threads)
        await_previous: If True, this will block if a prior command was
            submitted by another thread
    
    Returns:
        list of filtered and stripped response(s) to the command(s)
    
    Raises:
        ModemBusy if await_previous is False and a prior command is queued.
        AtException if an error occurred that is unrecognized.

    &#34;&#34;&#34;
    if not self.connected:
        raise ConnectionError(&#39;No connection to IDP modem&#39;)
    while self.commands.full():
        if not await_previous:
            raise ModemBusy
        pass
    self.commands.put(command)
    # TODO: allow for async(?)
    res: list = self.protocol.command(command, filter, timeout, self.debug)
    if self.error_detail and res and res[0] == &#39;ERROR&#39;:
        _log.error(f&#39;Error received for command {command}&#39;)
        err_res = self.protocol.command(&#39;ATS80?&#39;)
        if not err_res or err_res[0] == &#39;ERROR&#39;:
            raise AtException(&#39;Unhandled error getting last error code&#39;)
        last_err_code = err_res[0]
        detail = &#39;UNDEFINED&#39;
        if int(last_err_code) in AT_ERROR_CODES:
            detail = AT_ERROR_CODES[int(last_err_code)]
        res.append(f&#39;{detail} ({last_err_code})&#39;)
    self.commands.get()
    self.commands.task_done()
    return res</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.config_init"><code class="name flex">
<span>def <span class="ident">config_init</span></span>(<span>self, crc:Â boolÂ =Â False) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes modem communications with Echo, Verbose. CRC optional.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_init(self, crc: bool = False) -&gt; bool:
    &#34;&#34;&#34;Initializes modem communications with Echo, Verbose. CRC optional.&#34;&#34;&#34;
    def attempt(command: str) -&gt; bool:
        response = self.atcommand(command)
        return response[0] == &#39;OK&#39;
    # try at most twice
    command = f&#39;ATZ;E1;V1;Q0;%CRC={1 if crc else 0}&#39;
    success = attempt(command)
    if not success:
        success = attempt(command)
    if success:
        self.protocol.crc = crc
        self._at_config.crc = crc
    return success</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.config_nvm_save"><code class="name flex">
<span>def <span class="ident">config_nvm_save</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Sends the AT&amp;W command and returns True if successful.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_nvm_save(self) -&gt; bool:
    &#34;&#34;&#34;Sends the AT&amp;W command and returns True if successful.&#34;&#34;&#34;
    response = self.atcommand(&#39;AT&amp;W&#39;)
    return response[0] == &#39;OK&#39;</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.config_report"><code class="name flex">
<span>def <span class="ident">config_report</span></span>(<span>self) â€‘>Â tuple[dict,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Sends the AT&amp;V command to retrieve S-register settings.</p>
<h2 id="returns">Returns</h2>
<p>A tuple with two dictionaries (empty if failed) with:
at_config with booleans crc, echo, quiet and verbose
reg_config with S-register tags and integer values</p>
<h2 id="raises">Raises</h2>
<p>AtException if an error was returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_report(self) -&gt; &#39;tuple[dict, dict]&#39;:
    &#34;&#34;&#34;Sends the AT&amp;V command to retrieve S-register settings.
    
    Returns:
        A tuple with two dictionaries (empty if failed) with:
        at_config with booleans crc, echo, quiet and verbose
        reg_config with S-register tags and integer values
    
    Raises:
        AtException if an error was returned.

    &#34;&#34;&#34;
    response = self.atcommand(&#39;AT&amp;V&#39;)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    at_config = response[1]
    s_regs = response[2]
    echo, quiet, verbose, crc = at_config.split(&#39; &#39;)
    self._at_config.crc = bool(int(crc[4]))
    self._at_config.echo = bool(int(echo[1]))
    self._at_config.quiet = bool(int(quiet[1]))
    self._at_config.verbose = bool(int(verbose[1]))
    reg_config = {}
    for reg in s_regs.split(&#39; &#39;):
        name, value = reg.split(&#39;:&#39;)
        reg_config[name] = int(value)
    return (at_config, reg_config)</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.config_restore_factory"><code class="name flex">
<span>def <span class="ident">config_restore_factory</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Sends AT&amp;F to restore factory default and returns True on success.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_restore_factory(self) -&gt; bool:
    &#34;&#34;&#34;Sends AT&amp;F to restore factory default and returns True on success.&#34;&#34;&#34;
    response = self.atcommand(&#39;AT&amp;F&#39;)
    if response[0] == &#39;ERROR&#39;:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.config_restore_nvm"><code class="name flex">
<span>def <span class="ident">config_restore_nvm</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Sends ATZ to restore config from non-volatile memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_restore_nvm(self) -&gt; bool:
    &#34;&#34;&#34;Sends ATZ to restore config from non-volatile memory.&#34;&#34;&#34;
    response = self.atcommand(&#39;ATZ&#39;)
    if response[0] == &#39;ERROR&#39;:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.config_volatile_report"><code class="name flex">
<span>def <span class="ident">config_volatile_report</span></span>(<span>self) â€‘>Â dict|None</span>
</code></dt>
<dd>
<div class="desc"><p>Returns key S-register settings.</p>
<p>GNSS Mode (S39), GNSS fix timeout (S41), GNSS Continuous (S55),
GNSS Jamming Status (S56), GNSS Jamming Indicator (S57),
Low power Wakeup Period (S51)</p>
<h2 id="returns">Returns</h2>
<p>Dictionary of S-register values, or None if failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_volatile_report(self) -&gt; &#39;dict|None&#39;:
    &#34;&#34;&#34;Returns key S-register settings.
    
    GNSS Mode (S39), GNSS fix timeout (S41), GNSS Continuous (S55),
    GNSS Jamming Status (S56), GNSS Jamming Indicator (S57), 
    Low power Wakeup Period (S51)

    Returns:
        Dictionary of S-register values, or None if failed
        
    &#34;&#34;&#34;
    register_list = [
        &#39;S39&#39;,   #: GNSS Mode
        &#39;S41&#39;,   #: GNSS Fix Timeout
        &#39;S51&#39;,   #: Wakeup Interval
        &#39;S55&#39;,   #: GNSS Continuous
        &#39;S56&#39;,   #: GNSS Jamming Status
        &#39;S57&#39;,   #: GNSS Jamming Indicator
    ]
    command = &#39;AT&#39;
    for reg in register_list:
        command += f&#39;{reg if command == &#34;AT&#34; else &#34; &#34; + reg}?&#39;
    response = self.atcommand(command)
    if response[0] == &#39;ERROR&#39;:
        return None
    #: else
    response.remove(&#39;OK&#39;)
    volatile_regs = {}
    for r in range(len(response)):
        volatile_regs[register_list[r]] = int(response[r])
    return volatile_regs</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    self.transport, self.protocol = self.loop.run_until_complete(self.coro)
    self.loop.run_forever()
    _log.debug(f&#39;Transport: {self.transport}&#39;)</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.crc_enable"><code class="name flex">
<span>def <span class="ident">crc_enable</span></span>(<span>self, enable:Â boolÂ =Â True) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Sends the AT%CRC command and returns success flag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong></dt>
<dd>turn on CRC if True else turn off</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the operation succeeded else False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crc_enable(self, enable: bool = True) -&gt; bool:
    &#34;&#34;&#34;Sends the AT%CRC command and returns success flag.
    
    Args:
        enable: turn on CRC if True else turn off

    Returns:
        True if the operation succeeded else False

    &#34;&#34;&#34;
    command = f&#39;AT%CRC={1 if enable else 0}&#39;
    response = self.atcommand(command)
    if response[0] == &#39;ERROR&#39;:
        return False
    self.protocol.crc = enable
    self._at_config.crc = enable
    return True</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    self.loop.close()
    self.transport = None
    self.protocol = None</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.gnss_continuous_set"><code class="name flex">
<span>def <span class="ident">gnss_continuous_set</span></span>(<span>self, interval:Â intÂ =Â 0, doppler:Â boolÂ =Â True) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the GNSS continous mode (0 = on-demand).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interval</code></strong></dt>
<dd>Seconds between GNSS refresh.</dd>
<dt><strong><code>doppler</code></strong></dt>
<dd>Often required for moving assets.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if successful setting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnss_continuous_set(self,
                        interval: int = 0,
                        doppler: bool = True,
                        ) -&gt; bool:
    &#34;&#34;&#34;Sets the GNSS continous mode (0 = on-demand).
    
    Args:
        interval: Seconds between GNSS refresh.
        doppler: Often required for moving assets.
    
    Returns:
        True if successful setting.
    &#34;&#34;&#34;
    if interval &lt; 0 or interval &gt; 30:
        raise ValueError(&#39;GNSS continuous interval must be in range 0..30&#39;)
    response = self.atcommand(f&#39;AT%TRK={interval}{&#34;,1&#34; if doppler else &#34;&#34;}&#39;)
    if response[0] == &#39;ERROR&#39;:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.gnss_nmea_get"><code class="name flex">
<span>def <span class="ident">gnss_nmea_get</span></span>(<span>self, stale_secs:Â intÂ =Â 1, wait_secs:Â intÂ =Â 35, nmea:Â list[str]Â =Â ['RMC', 'GSA', 'GGA', 'GSV']) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of NMEA-formatted sentences from GNSS.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stale_secs</code></strong></dt>
<dd>Maximum age of fix in seconds (1..600)</dd>
<dt><strong><code>wait_secs</code></strong></dt>
<dd>Maximum time to wait for fix (1..600)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of NMEA sentences</p>
<h2 id="raises">Raises</h2>
<p>ValueError if parameter out of range
AtGnssTimeout if the fix timed out
AtException if any other error code was returned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnss_nmea_get(self,
                  stale_secs: int = GNSS_STALE_SECS,
                  wait_secs: int = GNSS_WAIT_SECS,
                  nmea: &#39;list[str]&#39; = [&#39;RMC&#39;, &#39;GSA&#39;, &#39;GGA&#39;, &#39;GSV&#39;],
                  ) -&gt; list:
    &#34;&#34;&#34;Returns a list of NMEA-formatted sentences from GNSS.

    Args:
        stale_secs: Maximum age of fix in seconds (1..600)
        wait_secs: Maximum time to wait for fix (1..600)

    Returns:
        List of NMEA sentences

    Raises:
        ValueError if parameter out of range
        AtGnssTimeout if the fix timed out
        AtException if any other error code was returned

    &#34;&#34;&#34;
    NMEA_SUPPORTED = [&#39;RMC&#39;, &#39;GGA&#39;, &#39;GSA&#39;, &#39;GSV&#39;]
    BUFFER_SECONDS = 5
    if (stale_secs not in range(1, 600+1) or
        wait_secs not in range(1, 600+1)):
        raise ValueError(&#39;stale_secs and wait_secs must be 1..600&#39;)
    sentences = &#39;&#39;
    for sentence in nmea:
        sentence = sentence.upper()
        if sentence not in NMEA_SUPPORTED:
            raise ValueError(f&#39;Unsupported NMEA sentence: {sentence}&#39;)
        if len(sentences) &gt; 0:
            sentences += &#39;,&#39;
        sentences += f&#39;&#34;{sentence}&#34;&#39;
    timeout = wait_secs + BUFFER_SECONDS
    request_time = time()
    response = self.atcommand(f&#39;AT%GPS={stale_secs}&#39;
                                    f&#39;,{wait_secs},{sentences}&#39;,
                                    timeout=timeout,
                                    filter=[&#39;%GPS:&#39;])
    if response[0] == &#39;ERROR&#39;:
        if self.error_detail:
            if &#39;TIMEOUT&#39; in response[1]:
                raise AtGnssTimeout(response[1])
        self._handle_at_exception(response)
    response.remove(&#39;OK&#39;)
    time_to_fix = round(time() - request_time, 3)
    if &#39;gnss_ttf&#39; not in self._statistics:
        self._statistics[&#39;gnss_ttf&#39;] = time_to_fix
    else:
        old_ttf = self._statistics[&#39;gnss_ttf&#39;]
        avg_ttf = round((time_to_fix + old_ttf) / 2, 3)
        self._statistics[&#39;gnss_ttf&#39;] = avg_ttf
    return response</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.message_mo_cancel"><code class="name flex">
<span>def <span class="ident">message_mo_cancel</span></span>(<span>self, name:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Cancels a mobile-originated message in the Tx ready state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_mo_cancel(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Cancels a mobile-originated message in the Tx ready state.&#34;&#34;&#34;
    response = self.atcommand(f&#39;AT%MGRC=&#34;{name}&#34;&#39;)
    if response[0] == &#39;ERROR&#39;:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.message_mo_clear"><code class="name flex">
<span>def <span class="ident">message_mo_clear</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the modem transmit queue and returns the count cancelled.</p>
<h2 id="returns">Returns</h2>
<p>Count of messages deleted, or -1 in case of error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_mo_clear(self) -&gt; int:
    &#34;&#34;&#34;Clears the modem transmit queue and returns the count cancelled.
    
    Returns:
        Count of messages deleted, or -1 in case of error

    &#34;&#34;&#34;
    list_response = self.atcommand(&#39;AT%MGRL&#39;, filter=[&#39;%MGRL:&#39;])
    if list_response[0] == &#39;ERROR&#39;:
        return -1
    message_count = len(list_response)
    for msg in list_response:
        del_response = self.atcommand(f&#39;AT%MGRD={msg}C&#39;)
        if del_response[0] == &#39;ERROR&#39;:
            _log.error(f&#39;Error clearing messages from transmit queue&#39;)
            return -1
    return message_count</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.message_mo_send"><code class="name flex">
<span>def <span class="ident">message_mo_send</span></span>(<span>self, data:Â bytes|bytearray|str, data_format:Â intÂ =Â DataFormat.BASE64, name:Â strÂ =Â None, priority:Â intÂ =Â MessagePriority.LOW, sin:Â intÂ =Â None, min:Â intÂ =Â None) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Submits a mobile-originated message to send.</p>
<p>When submitting raw bytes, the first byte will be used as SIN. The
first byte must not be in the reserved range (0..15).
When submitting a string, the <code>sin</code> field is expected to be set and
the data field will be appended to the <code>sin</code> byte and optionally the
<code>min</code> byte if specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The data raw bytes or UTF-8 Text, Hexadecimal or Base64 string</dd>
<dt><strong><code>data_format</code></strong></dt>
<dd>1=text, 2=hexadecimal, 3=base64 (default)</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Optional unique name up to 8 characters long. If none is
specified, use the 8 least-significant digits of unix timestamp.</dd>
<dt><strong><code>priority</code></strong></dt>
<dd>1=high, 4=low (default)</dd>
<dt><strong><code>sin</code></strong></dt>
<dd>Optional first byte of payload used for codec, required if data
is string type.</dd>
<dt><strong><code>min</code></strong></dt>
<dd>Optional second byte of payload used for codec</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Name of the message if successful, or the error string.</p>
<h2 id="raises">Raises</h2>
<p>AtException if an error was returned by the modem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_mo_send(self,
                    data: &#39;bytes|bytearray|str&#39;,
                    data_format: int = DataFormat.BASE64,
                    name: str = None,
                    priority: int = MessagePriority.LOW,
                    sin: int = None,
                    min: int = None,
                    ) -&gt; str:
    &#34;&#34;&#34;Submits a mobile-originated message to send.

    When submitting raw bytes, the first byte will be used as SIN. The
    first byte must not be in the reserved range (0..15).
    When submitting a string, the `sin` field is expected to be set and
    the data field will be appended to the `sin` byte and optionally the
    `min` byte if specified.
    
    Args:
        data: The data raw bytes or UTF-8 Text, Hexadecimal or Base64 string
        data_format: 1=text, 2=hexadecimal, 3=base64 (default)
        name: Optional unique name up to 8 characters long. If none is
            specified, use the 8 least-significant digits of unix timestamp.
        priority: 1=high, 4=low (default)
        sin: Optional first byte of payload used for codec, required if data
            is string type.
        min: Optional second byte of payload used for codec

    Returns:
        Name of the message if successful, or the error string.
    
    Raises:
        AtException if an error was returned by the modem.

    &#34;&#34;&#34;
    name = str(int(time()))[-8:] if not name else name[0:8]
    if isinstance(data, bytes) or isinstance(data, bytearray):
        sin = data[0]
        data = b64encode(data[1:]).decode(&#39;utf-8&#39;)
        data_format = DataFormat.BASE64
    elif not isinstance(data, str):
        raise ValueError(&#39;Invalid data must be bytes, bytearray or string&#39;)
    elif not isinstance(sin, int) or sin not in range(16, 256):
        raise ValueError(&#39;Invalid SIN must be 16..255&#39;)
    if isinstance(min, int) and min not in range(0, 256):
        raise ValueError(&#39;Invalid MIN must be 0..255&#39;)
    min = f&#39;.{min}&#39; if min is not None else &#39;&#39;
    data = f&#39;&#34;{data}&#34;&#39; if data_format == DataFormat.TEXT else data
    command = f&#39;AT%MGRT=&#34;{name}&#34;,{priority},{sin}{min},{data_format},{data}&#39;
    response = self.atcommand(command)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    return name</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.message_mo_state"><code class="name flex">
<span>def <span class="ident">message_mo_state</span></span>(<span>self, name:Â strÂ =Â None) â€‘>Â list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the message state(s) requested.</p>
<p>If no name filter is passed in, all available messages states
are returned.
Returns False is the request failed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The unique message name in the modem queue. If none is
provided, all available message states in transmit queue will be
returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of metadata for each message in transmit queue including:
- <code>name</code> (str) The ID in the modem transmit queue
- <code>state</code> (int) The state of the message
- <code>state_name</code> (str) The <code>MessageState.name</code>
- <code>size</code> (int) in bytes
- <code>sent</code> (int) in bytes for large message progress</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_mo_state(self, name: str = None) -&gt; &#39;list[dict]&#39;:
    &#34;&#34;&#34;Returns the message state(s) requested.
    
    If no name filter is passed in, all available messages states
    are returned.  Returns False is the request failed.

    Args:
        name: The unique message name in the modem queue. If none is
            provided, all available message states in transmit queue will be
            returned.

    Returns:
        List of metadata for each message in transmit queue including:
        - `name` (str) The ID in the modem transmit queue
        - `state` (int) The state of the message
        - `state_name` (str) The `MessageState.name`
        - `size` (int) in bytes
        - `sent` (int) in bytes for large message progress

    &#34;&#34;&#34;
    states = []
    name = f&#39;=&#34;{name}&#34;&#39; if name is not None else &#39;&#39;
    response = self.atcommand(f&#39;AT%MGRS{name}&#39;, filter=[&#39;%MGRS:&#39;])
    # %MGRS: &#34;&lt;name&gt;&#34;,&lt;msg_no&gt;,&lt;priority&gt;,&lt;sin&gt;,&lt;state&gt;,&lt;size&gt;,&lt;sent_bytes&gt;
    if response[0] != &#39;ERROR&#39;:
        response.remove(&#39;OK&#39;)
        for msg in response:
            if &#39;,&#39; in msg:
                detail = msg.split(&#39;,&#39;)
                states.append({
                    &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                    &#39;state&#39;: int(detail[4]),
                    &#39;state_name&#39;: MessageState(int(detail[4])).name,
                    &#39;size&#39;: int(detail[5]),
                    &#39;sent&#39;: int(detail[6]),
                })
    return states</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.message_mt_delete"><code class="name flex">
<span>def <span class="ident">message_mt_delete</span></span>(<span>self, name:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Marks a Return message for deletion by the modem.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The unique mobile-terminated name in the queue</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the operation succeeded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_mt_delete(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Marks a Return message for deletion by the modem.
    
    Args:
        name: The unique mobile-terminated name in the queue

    Returns:
        True if the operation succeeded

    &#34;&#34;&#34;
    response = self.atcommand(f&#39;AT%MGFM=&#34;{name}&#34;&#39;)
    if response[0] == &#39;ERROR&#39;:
        err = f&#39; ({response[1]})&#39; if self.error_detail else &#39;&#39;
        _log.error(f&#39;Error deleting message {name}{err}&#39;)
    return response[0] == &#39;OK&#39;</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.message_mt_get"><code class="name flex">
<span>def <span class="ident">message_mt_get</span></span>(<span>self, name:Â str, data_format:Â intÂ =Â DataFormat.BASE64, meta:Â boolÂ =Â False) â€‘>Â bytes|dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the payload of a specified mobile-terminated message.</p>
<p>Payload is presented as a string with encoding based on data_format. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The unique name in the modem queue e.g. FM01.01</dd>
<dt><strong><code>data_format</code></strong></dt>
<dd>text=1, hex=2, base64=3 (default)</dd>
<dt><strong><code>meta</code></strong></dt>
<dd>If False returns raw bytes, else returns formatted data
with metadata.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The raw data bytes if meta is False, or a dictionary with:
- <code>name</code> (str) The name assigned by the modem
- <code>system_message_number</code> (int) System-assigned number
- <code>system_message_sequence</code> (int) System-assigned number
- <code>sin</code> (int) First byte of payload
- <code>priority</code> (int)
- <code>state</code> (int) The message state number
- <code>state_name</code> (str) The <code>MessageState.name</code>
- <code>size</code> (int) in bytes
- <code>data_format</code> (int) 1=text, 2=hex, 3=base64
- <code>data</code> (str) presented based on data_format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_mt_get(self,
                   name: str,
                   data_format: int = DataFormat.BASE64,
                   meta: bool = False,
                   ) -&gt; &#39;bytes|dict&#39;:
    &#34;&#34;&#34;Returns the payload of a specified mobile-terminated message.
    
    Payload is presented as a string with encoding based on data_format. 

    Args:
        name: The unique name in the modem queue e.g. FM01.01
        data_format: text=1, hex=2, base64=3 (default)
        meta: If False returns raw bytes, else returns formatted data
            with metadata.

    Returns:
        The raw data bytes if meta is False, or a dictionary with:
        - `name` (str) The name assigned by the modem
        - `system_message_number` (int) System-assigned number
        - `system_message_sequence` (int) System-assigned number
        - `sin` (int) First byte of payload
        - `priority` (int)
        - `state` (int) The message state number
        - `state_name` (str) The `MessageState.name`
        - `size` (int) in bytes
        - `data_format` (int) 1=text, 2=hex, 3=base64
        - `data` (str) presented based on data_format

    &#34;&#34;&#34;
    if not meta and data_format != DataFormat.BASE64:
        data_format = DataFormat.BASE64
    response = self.atcommand(f&#39;AT%MGFG=&#34;{name}&#34;,{data_format}&#39;)
    if response[0] == &#39;ERROR&#39;:
        _log.error(f&#39;Error retrieving message {name}&#39;)
        self._handle_at_exception(response)
    #: name, number, priority, sin, state, length, data_format, data
    try:
        detail = response[0].split(&#39;,&#39;)
        sys_msg_num, sys_msg_seq = detail[1].split(&#39;.&#39;)
        msg_sin = int(detail[3])
        data_str_no_sin = detail[7]
        if data_format == DataFormat.HEX:
            data = hex(msg_sin) + data_str_no_sin.lower()
        elif data_format == DataFormat.BASE64:
            # add SIN byte to base64 blob
            databytes = bytes([msg_sin]) + b64decode(data_str_no_sin)
            if not meta:
                return databytes
            data = b64encode(databytes).decode(&#39;ascii&#39;)
        elif data_format == DataFormat.TEXT:
            data = f&#39;\\{msg_sin:02x}&#39; + data_str_no_sin
        return {
            &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
            &#39;system_message_number&#39;: int(sys_msg_num),
            &#39;system_message_sequence&#39;: int(sys_msg_seq),
            &#39;priority&#39;: int(detail[2]),
            &#39;sin&#39;: msg_sin,
            &#39;state&#39;: int(detail[4]),
            &#39;state_name&#39;: MessageState(int(detail[4])).name,
            &#39;size&#39;: int(detail[5]),
            &#39;data_format&#39;: data_format,
            &#39;data&#39;: data
        }
    except Exception as err:
        _log.exception(err)</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.message_mt_waiting"><code class="name flex">
<span>def <span class="ident">message_mt_waiting</span></span>(<span>self) â€‘>Â list[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of received mobile-terminated message information.</p>
<h2 id="returns">Returns</h2>
<p>List of message metadata in the receive queue including:
- <code>name</code> (str)
- <code>sin</code> (int) first byte of payload
- <code>priority</code> (int)
- <code>state</code> (int) The state number
- <code>state_name</code> (str) The <code>MessageState.name</code>
- <code>size</code> (int) in bytes
- <code>received</code> (int) in bytes for large message progress</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message_mt_waiting(self) -&gt; &#39;list[dict]&#39;:
    &#34;&#34;&#34;Returns a list of received mobile-terminated message information.
    
    Returns:
        List of message metadata in the receive queue including:
        - `name` (str)
        - `sin` (int) first byte of payload
        - `priority` (int)
        - `state` (int) The state number
        - `state_name` (str) The `MessageState.name`
        - `size` (int) in bytes
        - `received` (int) in bytes for large message progress

    &#34;&#34;&#34;
    waiting = []
    response = self.atcommand(&#39;AT%MGFN&#39;, filter=[&#39;%MGFN:&#39;])
    #: %MGFN: &#34;name&#34;,number,priority,sin,state,length,bytes_received
    if response[0] != &#39;ERROR&#39;:
        response.remove(&#39;OK&#39;)
        for msg in response:
            if (&#39;,&#39; in msg):
                detail = msg.split(&#39;,&#39;)
                waiting.append({
                    &#39;name&#39;: detail[0].replace(&#39;&#34;&#39;, &#39;&#39;),
                    &#39;sin&#39;: int(detail[3]),
                    &#39;priority&#39;: int(detail[2]),
                    &#39;state&#39;: int(detail[4]),
                    &#39;state_name&#39;: MessageState(int(detail[4])).name,
                    &#39;size&#39;: int(detail[5]),
                    &#39;received&#39;: int(detail[6])
                    })
    return waiting</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.s_register_get"><code class="name flex">
<span>def <span class="ident">s_register_get</span></span>(<span>self, register:Â str|int) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of the S-register requested.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>register</code></strong></dt>
<dd>The register name/number (e.g. S80)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>integer value or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def s_register_get(self, register: &#39;str|int&#39;) -&gt; int:
    &#34;&#34;&#34;Returns the value of the S-register requested.

    Args:
        register: The register name/number (e.g. S80)

    Returns:
        integer value or None
    &#34;&#34;&#34;
    if isinstance(register, str):
        try:
            register = int(register.replace(&#39;S&#39;, &#39;&#39;))
        except ValueError:
            raise ValueError(f&#39;Invalid S-register {register}&#39;)
    _log.debug(f&#39;Querying S-register {register}&#39;)
    response = self.atcommand(f&#39;ATS{register}?&#39;)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    return int(response[0])</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.s_register_get_definitions"><code class="name flex">
<span>def <span class="ident">s_register_get_definitions</span></span>(<span>self) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of S-register definitions.
R=read-only, S=signed, V=volatile</p>
<h2 id="returns">Returns</h2>
<p>tuple(register, RSV, current, default, minimum, maximum) or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def s_register_get_definitions(self) -&gt; list:
    &#34;&#34;&#34;Returns a list of S-register definitions.
    R=read-only, S=signed, V=volatile
    
    Returns:
        tuple(register, RSV, current, default, minimum, maximum) or None
    &#34;&#34;&#34;
    raise NotImplementedError
    #: AT%SREG
    #: Sreg, RSV, CurrentVal, DefaultVal, MinimumVal, MaximumVal
    response = self.atcommand(&#39;AT%SREG&#39;)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    response.remove(&#39;OK&#39;)
    # header_rows = response[0:1]
    # Sreg RSV CurrentVal NvmValue DefaultValue MinimumValue MaximumVal
    reg_defs = response[2:]
    registers = []
    for row in reg_defs:
        reg_def = row.split(&#39; &#39;)
        reg_def = tuple(filter(None, reg_def))
        registers.append(reg_def)
    return registers</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.satellite_status_get"><code class="name flex">
<span>def <span class="ident">satellite_status_get</span></span>(<span>self) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the control state and C/No.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary including:
- <code>satellite</code> (str)
- <code>beam_id</code> (str)
- <code>network_status</code> (str)
- <code>control_state</code> (int)
- <code>beamsearch</code> (str)
- <code>beamsearch_state</code> (int)
- <code>snr</code> (float)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def satellite_status_get(self) -&gt; dict:
    &#34;&#34;&#34;Returns the control state and C/No.
    
    Returns:
        Dictionary including:
        - `satellite` (str)
        - `beam_id` (str)
        - `network_status` (str)
        - `control_state` (int)
        - `beamsearch` (str)
        - `beamsearch_state` (int)
        - `snr` (float)
    
    &#34;&#34;&#34;
    if (&#39;sat_status&#39; in self._holdoffs and
        int(time()) - self._holdoffs[&#39;sat_status&#39;] &lt; SAT_STATUS_HOLDOFF):
        _log.debug(&#39;Ignoring repeat satellite status query&#39;)
        return
    _log.debug(&#39;Querying satellite status&#39;)
    self._holdoffs[&#39;sat_status&#39;] = int(time())
    # Trace events:
    #   Class 3 Subclass 1 C/N, Satellite Control State, Beam Search State
    #   Class 3 Subclass 5 Geo Beam ID
    command = (&#39;ATS90=3 S91=1 S92=1 S116? S122? S123?&#39;
               &#39; S90=3 S91=5 S92=1 S102?&#39;)
    response = self.atcommand(command)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    self._snr = round(int(response[0]) / 100.0, 2)
    self._ctrl_state = int(response[1])
    self._beamsearch_state = int(response[2])
    self._geo_beam_id = int(response[3])
    return {
        &#39;satellite&#39;: self.satellite,
        &#39;beam_id&#39;: self.beam_id,
        &#39;network_status&#39;: self.network_status,
        &#39;control_state&#39;: self._ctrl_state,
        &#39;beamsearch&#39;: self.beamsearch,
        &#39;beamsearch_state&#39;: self._beamsearch_state,
        &#39;snr&#39;: self._snr,
    }</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tell the modem to prepare for power-down.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self) -&gt; bool:
    &#34;&#34;&#34;Tell the modem to prepare for power-down.&#34;&#34;&#34;
    _log.warning(&#39;Attempting to shut down&#39;)
    response = self.atcommand(&#39;AT%OFF&#39;)
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    return True</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.trace_event_get"><code class="name flex">
<span>def <span class="ident">trace_event_get</span></span>(<span>self, event:Â tuple[int,Â int], meta:Â boolÂ =Â False) â€‘>Â str|dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the cached event by class/subclass.</p>
<p>NOTE: Metadata feature is experimental.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>tuple of (class, subclass)</dd>
<dt><strong><code>meta</code></strong></dt>
<dd>Returns the raw text string if False (default)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>String if raw is True or metadata dictionary including:
- <code>data_count</code> (int)
- <code>signed_bitmask</code> (str)
- <code>mobile_id</code> (str)
- <code>timestamp</code> (str)
- <code>class</code> (str)
- <code>subclass</code> (str)
- <code>priority</code> (str)
- <code>data</code> (str)</p>
<h2 id="raises">Raises</h2>
<p>AtException</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trace_event_get(self,
                    event: &#39;tuple[int, int]&#39;,
                    meta: bool = False,
                    ) -&gt; &#39;str|dict&#39;:
    &#34;&#34;&#34;Gets the cached event by class/subclass.

    NOTE: Metadata feature is experimental.

    Args:
        event: tuple of (class, subclass)
        meta: Returns the raw text string if False (default)
    
    Returns:
        String if raw is True or metadata dictionary including:
        - `data_count` (int)
        - `signed_bitmask` (str)
        - `mobile_id` (str)
        - `timestamp` (str)
        - `class` (str)
        - `subclass` (str)
        - `priority` (str)
        - `data` (str)
    
    Raises:
        AtException

    &#34;&#34;&#34;
    def signed32(n: int) -&gt; int:
        &#34;&#34;&#34;Converts an integer to signed 32-bit format.&#34;&#34;&#34;
        n = n &amp; 0xffffffff
        return (n ^ 0x80000000) - 0x80000000
    def event_timestamp(log_timestamp: int) -&gt; int:
        offset = int(datetime(2001, 1, 1, tzinfo=timezone.utc).timestamp())
        return log_timestamp + offset
    if not (isinstance(event, tuple) and len(event) == 2):
        raise ValueError(&#39;event_get expects (class, subclass)&#39;)
    trace_class, trace_subclass = event
    response = self.atcommand(f&#39;AT%EVNT={trace_class},{trace_subclass}&#39;,
                              filter=[&#39;%EVNT:&#39;])
    #: res %EVNT: &lt;dataCount&gt;,&lt;signedBitmask&gt;,&lt;MTID&gt;,&lt;timestamp&gt;,
    # &lt;class&gt;,&lt;subclass&gt;,&lt;priority&gt;,&lt;data0&gt;,&lt;data1&gt;,..,&lt;dataN&gt;
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    if not meta:
        return response[0]
    eventdata = response[0].split(&#39;,&#39;)
    event = {
        &#39;data_count&#39;: int(eventdata[0]),
        &#39;signed_bitmask&#39;: bin(int(eventdata[1])),
        &#39;timestamp&#39;: event_timestamp(int(eventdata[3])),
        &#39;class&#39;: int(eventdata[4]),
        &#39;subclass&#39;: int(eventdata[5]),
        &#39;priority&#39;: int(eventdata[6]),
        &#39;data&#39;: eventdata[7:]
    }
    iso_time = datetime.utcfromtimestamp(event[&#39;timestamp&#39;]).isoformat()
    event[&#39;isotime&#39;] = iso_time[:19] + &#39;Z&#39;
    bitmask = event[&#39;signed_bitmask&#39;][2:]
    while len(bitmask) &lt; event[&#39;data_count&#39;]:
        bitmask = &#39;0&#39; + bitmask
    for i, bit in enumerate(reversed(bitmask)):
        if bit == &#39;1&#39;:
            event[&#39;data&#39;][i] = signed32(int(event[&#39;data&#39;][i]))
        else:
            event[&#39;data&#39;][i] = int(event[&#39;data&#39;][i])
    # TODO lookup class/subclass definitions
    for trace_def in EVENT_TRACES:
        if trace_def.trace_class != trace_class:
            continue
        if trace_def.trace_subclass != trace_subclass:
            continue
        try:
            for i, value in enumerate(event[&#39;data&#39;]):
                tag, data_type = trace_def.data[i]
                new_value = value
                if &#39;flags&#39; in tag and isinstance(data_type, dict):
                    new_value = []
                    for flag in data_type:
                        if flag &amp; value:
                            new_value.append(data_type[flag])
                elif str(tag).endswith(&#39;_state&#39;):
                    if isinstance(data_type, dict):
                        new_value = data_type[value]
                    else:
                        try:   #: IntEnum
                            new_value = data_type(value)
                        except:
                            pass   # new_value stays as value
                event[&#39;data&#39;][i] = { tag: new_value }
        except Exception as err:
            _log.exception(err)
    return event</code></pre>
</details>
</dd>
<dt id="idpmodem.asyncio.modem.IdpModem.utc_time"><code class="name flex">
<span>def <span class="ident">utc_time</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns current UTC time of the modem in ISO8601 format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def utc_time(self) -&gt; str:
    &#34;&#34;&#34;Returns current UTC time of the modem in ISO8601 format.&#34;&#34;&#34;
    _log.debug(&#39;Querying system time&#39;)
    response = self.atcommand(&#39;AT%UTC&#39;, filter=[&#39;%UTC:&#39;])
    if response[0] == &#39;ERROR&#39;:
        self._handle_at_exception(response)
    return response[0].replace(&#39; &#39;, &#39;T&#39;) + &#39;Z&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idpmodem.asyncio.modem.ModemBusy"><code class="flex name class">
<span>class <span class="ident">ModemBusy</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates the modem is busy processing a prior command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModemBusy(Exception):
    &#34;&#34;&#34;Indicates the modem is busy processing a prior command.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="idpmodem.asyncio" href="index.html">idpmodem.asyncio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="idpmodem.asyncio.modem.AtConfiguration" href="#idpmodem.asyncio.modem.AtConfiguration">AtConfiguration</a></code></h4>
</li>
<li>
<h4><code><a title="idpmodem.asyncio.modem.IdpModem" href="#idpmodem.asyncio.modem.IdpModem">IdpModem</a></code></h4>
<ul class="">
<li><code><a title="idpmodem.asyncio.modem.IdpModem.BAUD_RATES" href="#idpmodem.asyncio.modem.IdpModem.BAUD_RATES">BAUD_RATES</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.OTHER_KWARGS" href="#idpmodem.asyncio.modem.IdpModem.OTHER_KWARGS">OTHER_KWARGS</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.PROTOCOL_KWARGS" href="#idpmodem.asyncio.modem.IdpModem.PROTOCOL_KWARGS">PROTOCOL_KWARGS</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.SERIAL_KWARGS" href="#idpmodem.asyncio.modem.IdpModem.SERIAL_KWARGS">SERIAL_KWARGS</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.atcommand" href="#idpmodem.asyncio.modem.IdpModem.atcommand">atcommand</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.baudrate" href="#idpmodem.asyncio.modem.IdpModem.baudrate">baudrate</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.beam_id" href="#idpmodem.asyncio.modem.IdpModem.beam_id">beam_id</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.beamsearch" href="#idpmodem.asyncio.modem.IdpModem.beamsearch">beamsearch</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.beamsearch_state" href="#idpmodem.asyncio.modem.IdpModem.beamsearch_state">beamsearch_state</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.config_init" href="#idpmodem.asyncio.modem.IdpModem.config_init">config_init</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.config_nvm_save" href="#idpmodem.asyncio.modem.IdpModem.config_nvm_save">config_nvm_save</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.config_report" href="#idpmodem.asyncio.modem.IdpModem.config_report">config_report</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.config_restore_factory" href="#idpmodem.asyncio.modem.IdpModem.config_restore_factory">config_restore_factory</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.config_restore_nvm" href="#idpmodem.asyncio.modem.IdpModem.config_restore_nvm">config_restore_nvm</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.config_volatile_report" href="#idpmodem.asyncio.modem.IdpModem.config_volatile_report">config_volatile_report</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.connect" href="#idpmodem.asyncio.modem.IdpModem.connect">connect</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.connected" href="#idpmodem.asyncio.modem.IdpModem.connected">connected</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.control_state" href="#idpmodem.asyncio.modem.IdpModem.control_state">control_state</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.crc" href="#idpmodem.asyncio.modem.IdpModem.crc">crc</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.crc_enable" href="#idpmodem.asyncio.modem.IdpModem.crc_enable">crc_enable</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.disconnect" href="#idpmodem.asyncio.modem.IdpModem.disconnect">disconnect</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.event_notification_monitor" href="#idpmodem.asyncio.modem.IdpModem.event_notification_monitor">event_notification_monitor</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.event_notifications" href="#idpmodem.asyncio.modem.IdpModem.event_notifications">event_notifications</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.gnss_continuous_set" href="#idpmodem.asyncio.modem.IdpModem.gnss_continuous_set">gnss_continuous_set</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.gnss_nmea_get" href="#idpmodem.asyncio.modem.IdpModem.gnss_nmea_get">gnss_nmea_get</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.gnss_refresh_interval" href="#idpmodem.asyncio.modem.IdpModem.gnss_refresh_interval">gnss_refresh_interval</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.location" href="#idpmodem.asyncio.modem.IdpModem.location">location</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.message_mo_cancel" href="#idpmodem.asyncio.modem.IdpModem.message_mo_cancel">message_mo_cancel</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.message_mo_clear" href="#idpmodem.asyncio.modem.IdpModem.message_mo_clear">message_mo_clear</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.message_mo_send" href="#idpmodem.asyncio.modem.IdpModem.message_mo_send">message_mo_send</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.message_mo_state" href="#idpmodem.asyncio.modem.IdpModem.message_mo_state">message_mo_state</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.message_mt_delete" href="#idpmodem.asyncio.modem.IdpModem.message_mt_delete">message_mt_delete</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.message_mt_get" href="#idpmodem.asyncio.modem.IdpModem.message_mt_get">message_mt_get</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.message_mt_waiting" href="#idpmodem.asyncio.modem.IdpModem.message_mt_waiting">message_mt_waiting</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.mobile_id" href="#idpmodem.asyncio.modem.IdpModem.mobile_id">mobile_id</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.network_status" href="#idpmodem.asyncio.modem.IdpModem.network_status">network_status</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.power_mode" href="#idpmodem.asyncio.modem.IdpModem.power_mode">power_mode</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.s_register_get" href="#idpmodem.asyncio.modem.IdpModem.s_register_get">s_register_get</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.s_register_get_definitions" href="#idpmodem.asyncio.modem.IdpModem.s_register_get_definitions">s_register_get_definitions</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.satellite" href="#idpmodem.asyncio.modem.IdpModem.satellite">satellite</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.satellite_status_get" href="#idpmodem.asyncio.modem.IdpModem.satellite_status_get">satellite_status_get</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.shutdown" href="#idpmodem.asyncio.modem.IdpModem.shutdown">shutdown</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.snr" href="#idpmodem.asyncio.modem.IdpModem.snr">snr</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.trace_event_get" href="#idpmodem.asyncio.modem.IdpModem.trace_event_get">trace_event_get</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.trace_event_monitor" href="#idpmodem.asyncio.modem.IdpModem.trace_event_monitor">trace_event_monitor</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.trace_events_cached" href="#idpmodem.asyncio.modem.IdpModem.trace_events_cached">trace_events_cached</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.transmitter_status" href="#idpmodem.asyncio.modem.IdpModem.transmitter_status">transmitter_status</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.utc_time" href="#idpmodem.asyncio.modem.IdpModem.utc_time">utc_time</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.versions" href="#idpmodem.asyncio.modem.IdpModem.versions">versions</a></code></li>
<li><code><a title="idpmodem.asyncio.modem.IdpModem.wakeup_period" href="#idpmodem.asyncio.modem.IdpModem.wakeup_period">wakeup_period</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="idpmodem.asyncio.modem.ModemBusy" href="#idpmodem.asyncio.modem.ModemBusy">ModemBusy</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>